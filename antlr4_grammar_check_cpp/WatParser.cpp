
// Generated from WatParser.g4 by ANTLR 4.13.1


#include "WatParserListener.h"
#include "WatParserVisitor.h"

#include "WatParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct WatParserStaticData final {
  WatParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  WatParserStaticData(const WatParserStaticData&) = delete;
  WatParserStaticData(WatParserStaticData&&) = delete;
  WatParserStaticData& operator=(const WatParserStaticData&) = delete;
  WatParserStaticData& operator=(WatParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag watparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
WatParserStaticData *watparserParserStaticData = nullptr;

void watparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (watparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(watparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<WatParserStaticData>(
    std::vector<std::string>{
      "value", "name", "value_type", "elem_type", "global_type", "def_type", 
      "func_type", "table_type", "memory_type", "type_use", "literal", "var_", 
      "bind_var", "instr", "plain_instr", "call_instr", "call_instr_params", 
      "call_instr_instr", "call_instr_params_instr", "call_instr_results_instr", 
      "block_instr", "block_type", "block", "expr", "expr1", "call_expr_type", 
      "call_expr_params", "call_expr_results", "if_block", "instr_list", 
      "const_expr", "func_", "func_fields", "func_fields_import", "func_fields_import_result", 
      "func_fields_body", "func_result_body", "func_body", "offset", "elem", 
      "table", "table_fields", "data", "memory", "memory_fields", "sglobal", 
      "global_fields", "import_desc", "simport", "inline_import", "export_desc", 
      "export_", "inline_export", "type_", "type_def", "start_", "module_field", 
      "module_", "script_module", "action_", "assertion", "cmd", "meta", 
      "wconst", "const_list", "script", "module"
    },
    std::vector<std::string>{
      "", "'('", "')'", "", "", "", "", "", "", "'funcref'", "'mut'", "'nop'", 
      "'unreachable'", "'drop'", "'block'", "'loop'", "'end'", "'br'", "'br_if'", 
      "'br_table'", "'return'", "'if'", "'then'", "'else'", "'select'", 
      "'call'", "'call_indirect'", "'local.get'", "'local.set'", "'local.tee'", 
      "'global.get'", "'global.set'", "", "", "", "", "", "", "", "", "", 
      "'memory.size'", "'memory.grow'", "'type'", "'func'", "'start'", "'param'", 
      "'result'", "'local'", "'global'", "'table'", "'memory'", "'elem'", 
      "'data'", "'offset'", "'import'", "'export'", "'module'", "'binary'", 
      "'quote'", "'script'", "'register'", "'invoke'", "'get'", "'assert_malformed'", 
      "'assert_invalid'", "'assert_unlinkable'", "'assert_return'", "'assert_return_canonical_nan'", 
      "'assert_return_arithmetic_nan'", "'assert_trap'", "'assert_exhaustion'", 
      "'input'", "'output'"
    },
    std::vector<std::string>{
      "", "LPAR", "RPAR", "NAT", "INT", "FLOAT", "STRING_", "VALUE_TYPE", 
      "CONST", "FUNCREF", "MUT", "NOP", "UNREACHABLE", "DROP", "BLOCK", 
      "LOOP", "END", "BR", "BR_IF", "BR_TABLE", "RETURN", "IF", "THEN", 
      "ELSE", "SELECT", "CALL", "CALL_INDIRECT", "LOCAL_GET", "LOCAL_SET", 
      "LOCAL_TEE", "GLOBAL_GET", "GLOBAL_SET", "LOAD", "STORE", "OFFSET_EQ_NAT", 
      "ALIGN_EQ_NAT", "UNARY", "BINARY", "TEST", "COMPARE", "CONVERT", "MEMORY_SIZE", 
      "MEMORY_GROW", "TYPE", "FUNC", "START_", "PARAM", "RESULT", "LOCAL", 
      "GLOBAL", "TABLE", "MEMORY", "ELEM", "DATA", "OFFSET", "IMPORT", "EXPORT", 
      "MODULE", "BIN", "QUOTE", "SCRIPT", "REGISTER", "INVOKE", "GET", "ASSERT_MALFORMED", 
      "ASSERT_INVALID", "ASSERT_UNLINKABLE", "ASSERT_RETURN", "ASSERT_RETURN_CANONICAL_NAN", 
      "ASSERT_RETURN_ARITHMETIC_NAN", "ASSERT_TRAP", "ASSERT_EXHAUSTION", 
      "INPUT", "OUTPUT", "VAR", "SPACE", "COMMENT"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,76,1004,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
  	35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
  	42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,
  	49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,
  	56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,
  	63,2,64,7,64,2,65,7,65,2,66,7,66,1,0,1,0,1,1,1,1,1,2,1,2,1,3,1,3,1,4,
  	1,4,1,4,1,4,1,4,1,4,3,4,149,8,4,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,5,6,159,
  	8,6,10,6,12,6,162,9,6,1,6,1,6,5,6,166,8,6,10,6,12,6,169,9,6,1,6,1,6,1,
  	6,1,6,3,6,175,8,6,1,6,5,6,178,8,6,10,6,12,6,181,9,6,1,7,1,7,3,7,185,8,
  	7,1,7,1,7,1,8,1,8,3,8,191,8,8,1,9,1,9,1,9,1,9,1,9,1,10,1,10,1,11,1,11,
  	1,12,1,12,1,13,1,13,1,13,1,13,3,13,208,8,13,1,14,1,14,1,14,1,14,1,14,
  	1,14,1,14,1,14,1,14,1,14,4,14,220,8,14,11,14,12,14,221,1,14,1,14,1,14,
  	1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,3,14,239,
  	8,14,1,14,3,14,242,8,14,1,14,1,14,3,14,246,8,14,1,14,3,14,249,8,14,1,
  	14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,3,14,260,8,14,1,15,1,15,3,
  	15,264,8,15,1,15,1,15,1,16,1,16,1,16,5,16,271,8,16,10,16,12,16,274,9,
  	16,1,16,5,16,277,8,16,10,16,12,16,280,9,16,1,16,1,16,1,16,5,16,285,8,
  	16,10,16,12,16,288,9,16,1,16,5,16,291,8,16,10,16,12,16,294,9,16,1,17,
  	1,17,3,17,298,8,17,1,17,1,17,1,18,1,18,1,18,5,18,305,8,18,10,18,12,18,
  	308,9,18,1,18,5,18,311,8,18,10,18,12,18,314,9,18,1,18,1,18,1,19,1,19,
  	1,19,5,19,321,8,19,10,19,12,19,324,9,19,1,19,5,19,327,8,19,10,19,12,19,
  	330,9,19,1,19,1,19,1,20,1,20,3,20,336,8,20,1,20,1,20,1,20,3,20,341,8,
  	20,1,20,1,20,3,20,345,8,20,1,20,1,20,1,20,3,20,350,8,20,1,20,3,20,353,
  	8,20,1,20,1,20,3,20,357,8,20,3,20,359,8,20,1,21,1,21,1,21,1,21,1,21,1,
  	22,3,22,367,8,22,1,22,1,22,1,23,1,23,1,23,1,23,1,24,1,24,5,24,377,8,24,
  	10,24,12,24,380,9,24,1,24,1,24,1,24,1,24,3,24,386,8,24,1,24,1,24,1,24,
  	3,24,391,8,24,1,24,1,24,1,24,3,24,396,8,24,1,24,3,24,399,8,24,1,25,3,
  	25,402,8,25,1,25,1,25,1,26,1,26,1,26,5,26,409,8,26,10,26,12,26,412,9,
  	26,1,26,5,26,415,8,26,10,26,12,26,418,9,26,1,26,1,26,1,27,1,27,1,27,5,
  	27,425,8,27,10,27,12,27,428,9,27,1,27,5,27,431,8,27,10,27,12,27,434,9,
  	27,1,27,5,27,437,8,27,10,27,12,27,440,9,27,1,28,1,28,1,28,1,28,5,28,446,
  	8,28,10,28,12,28,449,9,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,
  	3,28,460,8,28,3,28,462,8,28,1,29,5,29,465,8,29,10,29,12,29,468,9,29,1,
  	29,3,29,471,8,29,1,30,1,30,1,31,1,31,1,31,3,31,478,8,31,1,31,1,31,1,31,
  	1,32,3,32,484,8,32,1,32,1,32,1,32,3,32,489,8,32,1,32,1,32,1,32,1,32,1,
  	32,3,32,496,8,32,1,33,1,33,1,33,5,33,501,8,33,10,33,12,33,504,9,33,1,
  	33,1,33,1,33,1,33,1,33,1,33,1,33,3,33,513,8,33,1,33,1,33,1,34,1,34,1,
  	34,5,34,520,8,34,10,34,12,34,523,9,34,1,34,5,34,526,8,34,10,34,12,34,
  	529,9,34,1,35,1,35,1,35,5,35,534,8,35,10,35,12,35,537,9,35,1,35,1,35,
  	1,35,1,35,1,35,1,35,1,35,5,35,546,8,35,10,35,12,35,549,9,35,1,35,1,35,
  	1,36,1,36,1,36,5,36,556,8,36,10,36,12,36,559,9,36,1,36,5,36,562,8,36,
  	10,36,12,36,565,9,36,1,36,1,36,1,37,1,37,1,37,5,37,572,8,37,10,37,12,
  	37,575,9,37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,5,37,584,8,37,10,37,12,
  	37,587,9,37,1,37,1,37,1,38,1,38,1,38,1,38,1,38,1,38,3,38,597,8,38,1,39,
  	1,39,1,39,3,39,602,8,39,1,39,1,39,5,39,606,8,39,10,39,12,39,609,9,39,
  	1,39,1,39,1,40,1,40,1,40,3,40,616,8,40,1,40,1,40,1,40,1,41,1,41,1,41,
  	1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,5,41,632,8,41,10,41,12,41,635,
  	9,41,1,41,1,41,3,41,639,8,41,1,42,1,42,1,42,3,42,644,8,42,1,42,1,42,5,
  	42,648,8,42,10,42,12,42,651,9,42,1,42,1,42,1,43,1,43,1,43,3,43,658,8,
  	43,1,43,1,43,1,43,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,5,
  	44,673,8,44,10,44,12,44,676,9,44,1,44,3,44,679,8,44,1,45,1,45,1,45,3,
  	45,684,8,45,1,45,1,45,1,45,1,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,1,
  	46,3,46,698,8,46,1,47,1,47,1,47,3,47,703,8,47,1,47,1,47,1,47,1,47,1,47,
  	1,47,3,47,711,8,47,1,47,1,47,1,47,1,47,1,47,1,47,3,47,719,8,47,1,47,1,
  	47,1,47,1,47,1,47,1,47,3,47,727,8,47,1,47,1,47,1,47,1,47,1,47,1,47,3,
  	47,735,8,47,1,47,1,47,1,47,3,47,740,8,47,1,48,1,48,1,48,1,48,1,48,1,48,
  	1,48,1,49,1,49,1,49,1,49,1,49,1,49,1,50,1,50,1,50,1,50,1,50,1,50,1,50,
  	1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,3,50,
  	775,8,50,1,51,1,51,1,51,1,51,1,51,1,51,1,52,1,52,1,52,1,52,1,52,1,53,
  	1,53,1,54,1,54,1,54,3,54,793,8,54,1,54,1,54,1,54,1,55,1,55,1,55,1,55,
  	1,55,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,3,56,813,8,56,
  	1,57,1,57,1,57,3,57,818,8,57,1,57,5,57,821,8,57,10,57,12,57,824,9,57,
  	1,57,1,57,1,58,1,58,1,58,1,58,3,58,832,8,58,1,58,1,58,5,58,836,8,58,10,
  	58,12,58,839,9,58,1,58,3,58,842,8,58,1,59,1,59,1,59,3,59,847,8,59,1,59,
  	1,59,1,59,1,59,1,59,1,59,1,59,3,59,856,8,59,1,59,1,59,1,59,3,59,861,8,
  	59,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,
  	60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,
  	60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,
  	60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,3,60,915,8,60,1,
  	61,1,61,1,61,1,61,1,61,1,61,1,61,3,61,924,8,61,1,61,1,61,1,61,3,61,929,
  	8,61,1,62,1,62,1,62,3,62,934,8,62,1,62,5,62,937,8,62,10,62,12,62,940,
  	9,62,1,62,1,62,1,62,1,62,3,62,946,8,62,1,62,1,62,1,62,1,62,1,62,3,62,
  	953,8,62,1,62,1,62,1,62,1,62,1,62,3,62,960,8,62,1,62,3,62,963,8,62,1,
  	63,1,63,1,63,1,63,1,63,1,64,5,64,971,8,64,10,64,12,64,974,9,64,1,65,5,
  	65,977,8,65,10,65,12,65,980,9,65,1,65,1,65,4,65,984,8,65,11,65,12,65,
  	985,1,65,1,65,3,65,990,8,65,1,66,1,66,1,66,1,66,5,66,996,8,66,10,66,12,
  	66,999,9,66,1,66,3,66,1002,8,66,1,66,0,0,67,0,2,4,6,8,10,12,14,16,18,
  	20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,
  	66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,
  	110,112,114,116,118,120,122,124,126,128,130,132,0,5,1,0,4,5,1,0,3,5,2,
  	0,3,3,74,74,1,0,14,15,1,0,58,59,1104,0,134,1,0,0,0,2,136,1,0,0,0,4,138,
  	1,0,0,0,6,140,1,0,0,0,8,148,1,0,0,0,10,150,1,0,0,0,12,179,1,0,0,0,14,
  	182,1,0,0,0,16,188,1,0,0,0,18,192,1,0,0,0,20,197,1,0,0,0,22,199,1,0,0,
  	0,24,201,1,0,0,0,26,207,1,0,0,0,28,259,1,0,0,0,30,261,1,0,0,0,32,278,
  	1,0,0,0,34,295,1,0,0,0,36,312,1,0,0,0,38,328,1,0,0,0,40,358,1,0,0,0,42,
  	360,1,0,0,0,44,366,1,0,0,0,46,370,1,0,0,0,48,398,1,0,0,0,50,401,1,0,0,
  	0,52,416,1,0,0,0,54,432,1,0,0,0,56,461,1,0,0,0,58,466,1,0,0,0,60,472,
  	1,0,0,0,62,474,1,0,0,0,64,495,1,0,0,0,66,512,1,0,0,0,68,527,1,0,0,0,70,
  	547,1,0,0,0,72,563,1,0,0,0,74,585,1,0,0,0,76,596,1,0,0,0,78,598,1,0,0,
  	0,80,612,1,0,0,0,82,638,1,0,0,0,84,640,1,0,0,0,86,654,1,0,0,0,88,678,
  	1,0,0,0,90,680,1,0,0,0,92,697,1,0,0,0,94,739,1,0,0,0,96,741,1,0,0,0,98,
  	748,1,0,0,0,100,774,1,0,0,0,102,776,1,0,0,0,104,782,1,0,0,0,106,787,1,
  	0,0,0,108,789,1,0,0,0,110,797,1,0,0,0,112,812,1,0,0,0,114,814,1,0,0,0,
  	116,841,1,0,0,0,118,860,1,0,0,0,120,914,1,0,0,0,122,928,1,0,0,0,124,962,
  	1,0,0,0,126,964,1,0,0,0,128,972,1,0,0,0,130,989,1,0,0,0,132,1001,1,0,
  	0,0,134,135,7,0,0,0,135,1,1,0,0,0,136,137,5,6,0,0,137,3,1,0,0,0,138,139,
  	5,7,0,0,139,5,1,0,0,0,140,141,5,9,0,0,141,7,1,0,0,0,142,149,3,4,2,0,143,
  	144,5,1,0,0,144,145,5,10,0,0,145,146,3,4,2,0,146,147,5,2,0,0,147,149,
  	1,0,0,0,148,142,1,0,0,0,148,143,1,0,0,0,149,9,1,0,0,0,150,151,5,1,0,0,
  	151,152,5,44,0,0,152,153,3,12,6,0,153,154,5,2,0,0,154,11,1,0,0,0,155,
  	174,5,1,0,0,156,160,5,47,0,0,157,159,3,4,2,0,158,157,1,0,0,0,159,162,
  	1,0,0,0,160,158,1,0,0,0,160,161,1,0,0,0,161,175,1,0,0,0,162,160,1,0,0,
  	0,163,167,5,46,0,0,164,166,3,4,2,0,165,164,1,0,0,0,166,169,1,0,0,0,167,
  	165,1,0,0,0,167,168,1,0,0,0,168,175,1,0,0,0,169,167,1,0,0,0,170,171,5,
  	46,0,0,171,172,3,24,12,0,172,173,3,4,2,0,173,175,1,0,0,0,174,156,1,0,
  	0,0,174,163,1,0,0,0,174,170,1,0,0,0,175,176,1,0,0,0,176,178,5,2,0,0,177,
  	155,1,0,0,0,178,181,1,0,0,0,179,177,1,0,0,0,179,180,1,0,0,0,180,13,1,
  	0,0,0,181,179,1,0,0,0,182,184,5,3,0,0,183,185,5,3,0,0,184,183,1,0,0,0,
  	184,185,1,0,0,0,185,186,1,0,0,0,186,187,3,6,3,0,187,15,1,0,0,0,188,190,
  	5,3,0,0,189,191,5,3,0,0,190,189,1,0,0,0,190,191,1,0,0,0,191,17,1,0,0,
  	0,192,193,5,1,0,0,193,194,5,43,0,0,194,195,3,22,11,0,195,196,5,2,0,0,
  	196,19,1,0,0,0,197,198,7,1,0,0,198,21,1,0,0,0,199,200,7,2,0,0,200,23,
  	1,0,0,0,201,202,5,74,0,0,202,25,1,0,0,0,203,208,3,28,14,0,204,208,3,34,
  	17,0,205,208,3,40,20,0,206,208,3,46,23,0,207,203,1,0,0,0,207,204,1,0,
  	0,0,207,205,1,0,0,0,207,206,1,0,0,0,208,27,1,0,0,0,209,260,5,12,0,0,210,
  	260,5,11,0,0,211,260,5,13,0,0,212,260,5,24,0,0,213,214,5,17,0,0,214,260,
  	3,22,11,0,215,216,5,18,0,0,216,260,3,22,11,0,217,219,5,19,0,0,218,220,
  	3,22,11,0,219,218,1,0,0,0,220,221,1,0,0,0,221,219,1,0,0,0,221,222,1,0,
  	0,0,222,260,1,0,0,0,223,260,5,20,0,0,224,225,5,25,0,0,225,260,3,22,11,
  	0,226,227,5,27,0,0,227,260,3,22,11,0,228,229,5,28,0,0,229,260,3,22,11,
  	0,230,231,5,29,0,0,231,260,3,22,11,0,232,233,5,30,0,0,233,260,3,22,11,
  	0,234,235,5,31,0,0,235,260,3,22,11,0,236,238,5,32,0,0,237,239,5,34,0,
  	0,238,237,1,0,0,0,238,239,1,0,0,0,239,241,1,0,0,0,240,242,5,35,0,0,241,
  	240,1,0,0,0,241,242,1,0,0,0,242,260,1,0,0,0,243,245,5,33,0,0,244,246,
  	5,34,0,0,245,244,1,0,0,0,245,246,1,0,0,0,246,248,1,0,0,0,247,249,5,35,
  	0,0,248,247,1,0,0,0,248,249,1,0,0,0,249,260,1,0,0,0,250,260,5,41,0,0,
  	251,260,5,42,0,0,252,253,5,8,0,0,253,260,3,20,10,0,254,260,5,38,0,0,255,
  	260,5,39,0,0,256,260,5,36,0,0,257,260,5,37,0,0,258,260,5,40,0,0,259,209,
  	1,0,0,0,259,210,1,0,0,0,259,211,1,0,0,0,259,212,1,0,0,0,259,213,1,0,0,
  	0,259,215,1,0,0,0,259,217,1,0,0,0,259,223,1,0,0,0,259,224,1,0,0,0,259,
  	226,1,0,0,0,259,228,1,0,0,0,259,230,1,0,0,0,259,232,1,0,0,0,259,234,1,
  	0,0,0,259,236,1,0,0,0,259,243,1,0,0,0,259,250,1,0,0,0,259,251,1,0,0,0,
  	259,252,1,0,0,0,259,254,1,0,0,0,259,255,1,0,0,0,259,256,1,0,0,0,259,257,
  	1,0,0,0,259,258,1,0,0,0,260,29,1,0,0,0,261,263,5,26,0,0,262,264,3,18,
  	9,0,263,262,1,0,0,0,263,264,1,0,0,0,264,265,1,0,0,0,265,266,3,32,16,0,
  	266,31,1,0,0,0,267,268,5,1,0,0,268,272,5,46,0,0,269,271,3,4,2,0,270,269,
  	1,0,0,0,271,274,1,0,0,0,272,270,1,0,0,0,272,273,1,0,0,0,273,275,1,0,0,
  	0,274,272,1,0,0,0,275,277,5,2,0,0,276,267,1,0,0,0,277,280,1,0,0,0,278,
  	276,1,0,0,0,278,279,1,0,0,0,279,292,1,0,0,0,280,278,1,0,0,0,281,282,5,
  	1,0,0,282,286,5,47,0,0,283,285,3,4,2,0,284,283,1,0,0,0,285,288,1,0,0,
  	0,286,284,1,0,0,0,286,287,1,0,0,0,287,289,1,0,0,0,288,286,1,0,0,0,289,
  	291,5,2,0,0,290,281,1,0,0,0,291,294,1,0,0,0,292,290,1,0,0,0,292,293,1,
  	0,0,0,293,33,1,0,0,0,294,292,1,0,0,0,295,297,5,26,0,0,296,298,3,18,9,
  	0,297,296,1,0,0,0,297,298,1,0,0,0,298,299,1,0,0,0,299,300,3,36,18,0,300,
  	35,1,0,0,0,301,302,5,1,0,0,302,306,5,46,0,0,303,305,3,4,2,0,304,303,1,
  	0,0,0,305,308,1,0,0,0,306,304,1,0,0,0,306,307,1,0,0,0,307,309,1,0,0,0,
  	308,306,1,0,0,0,309,311,5,2,0,0,310,301,1,0,0,0,311,314,1,0,0,0,312,310,
  	1,0,0,0,312,313,1,0,0,0,313,315,1,0,0,0,314,312,1,0,0,0,315,316,3,38,
  	19,0,316,37,1,0,0,0,317,318,5,1,0,0,318,322,5,47,0,0,319,321,3,4,2,0,
  	320,319,1,0,0,0,321,324,1,0,0,0,322,320,1,0,0,0,322,323,1,0,0,0,323,325,
  	1,0,0,0,324,322,1,0,0,0,325,327,5,2,0,0,326,317,1,0,0,0,327,330,1,0,0,
  	0,328,326,1,0,0,0,328,329,1,0,0,0,329,331,1,0,0,0,330,328,1,0,0,0,331,
  	332,3,26,13,0,332,39,1,0,0,0,333,335,7,3,0,0,334,336,3,24,12,0,335,334,
  	1,0,0,0,335,336,1,0,0,0,336,337,1,0,0,0,337,338,3,44,22,0,338,340,5,16,
  	0,0,339,341,3,24,12,0,340,339,1,0,0,0,340,341,1,0,0,0,341,359,1,0,0,0,
  	342,344,5,21,0,0,343,345,3,24,12,0,344,343,1,0,0,0,344,345,1,0,0,0,345,
  	346,1,0,0,0,346,352,3,44,22,0,347,349,5,23,0,0,348,350,3,24,12,0,349,
  	348,1,0,0,0,349,350,1,0,0,0,350,351,1,0,0,0,351,353,3,58,29,0,352,347,
  	1,0,0,0,352,353,1,0,0,0,353,354,1,0,0,0,354,356,5,16,0,0,355,357,3,24,
  	12,0,356,355,1,0,0,0,356,357,1,0,0,0,357,359,1,0,0,0,358,333,1,0,0,0,
  	358,342,1,0,0,0,359,41,1,0,0,0,360,361,5,1,0,0,361,362,5,47,0,0,362,363,
  	3,4,2,0,363,364,5,2,0,0,364,43,1,0,0,0,365,367,3,42,21,0,366,365,1,0,
  	0,0,366,367,1,0,0,0,367,368,1,0,0,0,368,369,3,58,29,0,369,45,1,0,0,0,
  	370,371,5,1,0,0,371,372,3,48,24,0,372,373,5,2,0,0,373,47,1,0,0,0,374,
  	378,3,28,14,0,375,377,3,46,23,0,376,375,1,0,0,0,377,380,1,0,0,0,378,376,
  	1,0,0,0,378,379,1,0,0,0,379,399,1,0,0,0,380,378,1,0,0,0,381,382,5,26,
  	0,0,382,399,3,50,25,0,383,385,5,14,0,0,384,386,3,24,12,0,385,384,1,0,
  	0,0,385,386,1,0,0,0,386,387,1,0,0,0,387,399,3,44,22,0,388,390,5,15,0,
  	0,389,391,3,24,12,0,390,389,1,0,0,0,390,391,1,0,0,0,391,392,1,0,0,0,392,
  	399,3,44,22,0,393,395,5,21,0,0,394,396,3,24,12,0,395,394,1,0,0,0,395,
  	396,1,0,0,0,396,397,1,0,0,0,397,399,3,56,28,0,398,374,1,0,0,0,398,381,
  	1,0,0,0,398,383,1,0,0,0,398,388,1,0,0,0,398,393,1,0,0,0,399,49,1,0,0,
  	0,400,402,3,18,9,0,401,400,1,0,0,0,401,402,1,0,0,0,402,403,1,0,0,0,403,
  	404,3,52,26,0,404,51,1,0,0,0,405,406,5,1,0,0,406,410,5,46,0,0,407,409,
  	3,4,2,0,408,407,1,0,0,0,409,412,1,0,0,0,410,408,1,0,0,0,410,411,1,0,0,
  	0,411,413,1,0,0,0,412,410,1,0,0,0,413,415,5,2,0,0,414,405,1,0,0,0,415,
  	418,1,0,0,0,416,414,1,0,0,0,416,417,1,0,0,0,417,419,1,0,0,0,418,416,1,
  	0,0,0,419,420,3,54,27,0,420,53,1,0,0,0,421,422,5,1,0,0,422,426,5,47,0,
  	0,423,425,3,4,2,0,424,423,1,0,0,0,425,428,1,0,0,0,426,424,1,0,0,0,426,
  	427,1,0,0,0,427,429,1,0,0,0,428,426,1,0,0,0,429,431,5,2,0,0,430,421,1,
  	0,0,0,431,434,1,0,0,0,432,430,1,0,0,0,432,433,1,0,0,0,433,438,1,0,0,0,
  	434,432,1,0,0,0,435,437,3,46,23,0,436,435,1,0,0,0,437,440,1,0,0,0,438,
  	436,1,0,0,0,438,439,1,0,0,0,439,55,1,0,0,0,440,438,1,0,0,0,441,442,3,
  	42,21,0,442,443,3,56,28,0,443,462,1,0,0,0,444,446,3,46,23,0,445,444,1,
  	0,0,0,446,449,1,0,0,0,447,445,1,0,0,0,447,448,1,0,0,0,448,450,1,0,0,0,
  	449,447,1,0,0,0,450,451,5,1,0,0,451,452,5,22,0,0,452,453,3,58,29,0,453,
  	459,5,2,0,0,454,455,5,1,0,0,455,456,5,23,0,0,456,457,3,58,29,0,457,458,
  	5,2,0,0,458,460,1,0,0,0,459,454,1,0,0,0,459,460,1,0,0,0,460,462,1,0,0,
  	0,461,441,1,0,0,0,461,447,1,0,0,0,462,57,1,0,0,0,463,465,3,26,13,0,464,
  	463,1,0,0,0,465,468,1,0,0,0,466,464,1,0,0,0,466,467,1,0,0,0,467,470,1,
  	0,0,0,468,466,1,0,0,0,469,471,3,30,15,0,470,469,1,0,0,0,470,471,1,0,0,
  	0,471,59,1,0,0,0,472,473,3,58,29,0,473,61,1,0,0,0,474,475,5,1,0,0,475,
  	477,5,44,0,0,476,478,3,24,12,0,477,476,1,0,0,0,477,478,1,0,0,0,478,479,
  	1,0,0,0,479,480,3,64,32,0,480,481,5,2,0,0,481,63,1,0,0,0,482,484,3,18,
  	9,0,483,482,1,0,0,0,483,484,1,0,0,0,484,485,1,0,0,0,485,496,3,70,35,0,
  	486,488,3,98,49,0,487,489,3,18,9,0,488,487,1,0,0,0,488,489,1,0,0,0,489,
  	490,1,0,0,0,490,491,3,66,33,0,491,496,1,0,0,0,492,493,3,104,52,0,493,
  	494,3,64,32,0,494,496,1,0,0,0,495,483,1,0,0,0,495,486,1,0,0,0,495,492,
  	1,0,0,0,496,65,1,0,0,0,497,498,5,1,0,0,498,502,5,46,0,0,499,501,3,4,2,
  	0,500,499,1,0,0,0,501,504,1,0,0,0,502,500,1,0,0,0,502,503,1,0,0,0,503,
  	505,1,0,0,0,504,502,1,0,0,0,505,513,5,2,0,0,506,507,5,1,0,0,507,508,5,
  	46,0,0,508,509,3,24,12,0,509,510,3,4,2,0,510,511,5,2,0,0,511,513,1,0,
  	0,0,512,497,1,0,0,0,512,506,1,0,0,0,513,514,1,0,0,0,514,515,3,68,34,0,
  	515,67,1,0,0,0,516,517,5,1,0,0,517,521,5,47,0,0,518,520,3,4,2,0,519,518,
  	1,0,0,0,520,523,1,0,0,0,521,519,1,0,0,0,521,522,1,0,0,0,522,524,1,0,0,
  	0,523,521,1,0,0,0,524,526,5,2,0,0,525,516,1,0,0,0,526,529,1,0,0,0,527,
  	525,1,0,0,0,527,528,1,0,0,0,528,69,1,0,0,0,529,527,1,0,0,0,530,531,5,
  	1,0,0,531,535,5,46,0,0,532,534,3,4,2,0,533,532,1,0,0,0,534,537,1,0,0,
  	0,535,533,1,0,0,0,535,536,1,0,0,0,536,538,1,0,0,0,537,535,1,0,0,0,538,
  	546,5,2,0,0,539,540,5,1,0,0,540,541,5,46,0,0,541,542,3,24,12,0,542,543,
  	3,4,2,0,543,544,5,2,0,0,544,546,1,0,0,0,545,530,1,0,0,0,545,539,1,0,0,
  	0,546,549,1,0,0,0,547,545,1,0,0,0,547,548,1,0,0,0,548,550,1,0,0,0,549,
  	547,1,0,0,0,550,551,3,72,36,0,551,71,1,0,0,0,552,553,5,1,0,0,553,557,
  	5,47,0,0,554,556,3,4,2,0,555,554,1,0,0,0,556,559,1,0,0,0,557,555,1,0,
  	0,0,557,558,1,0,0,0,558,560,1,0,0,0,559,557,1,0,0,0,560,562,5,2,0,0,561,
  	552,1,0,0,0,562,565,1,0,0,0,563,561,1,0,0,0,563,564,1,0,0,0,564,566,1,
  	0,0,0,565,563,1,0,0,0,566,567,3,74,37,0,567,73,1,0,0,0,568,569,5,1,0,
  	0,569,573,5,48,0,0,570,572,3,4,2,0,571,570,1,0,0,0,572,575,1,0,0,0,573,
  	571,1,0,0,0,573,574,1,0,0,0,574,576,1,0,0,0,575,573,1,0,0,0,576,584,5,
  	2,0,0,577,578,5,1,0,0,578,579,5,48,0,0,579,580,3,24,12,0,580,581,3,4,
  	2,0,581,582,5,2,0,0,582,584,1,0,0,0,583,568,1,0,0,0,583,577,1,0,0,0,584,
  	587,1,0,0,0,585,583,1,0,0,0,585,586,1,0,0,0,586,588,1,0,0,0,587,585,1,
  	0,0,0,588,589,3,58,29,0,589,75,1,0,0,0,590,591,5,1,0,0,591,592,5,54,0,
  	0,592,593,3,60,30,0,593,594,5,2,0,0,594,597,1,0,0,0,595,597,3,46,23,0,
  	596,590,1,0,0,0,596,595,1,0,0,0,597,77,1,0,0,0,598,599,5,1,0,0,599,601,
  	5,52,0,0,600,602,3,22,11,0,601,600,1,0,0,0,601,602,1,0,0,0,602,603,1,
  	0,0,0,603,607,3,76,38,0,604,606,3,22,11,0,605,604,1,0,0,0,606,609,1,0,
  	0,0,607,605,1,0,0,0,607,608,1,0,0,0,608,610,1,0,0,0,609,607,1,0,0,0,610,
  	611,5,2,0,0,611,79,1,0,0,0,612,613,5,1,0,0,613,615,5,50,0,0,614,616,3,
  	24,12,0,615,614,1,0,0,0,615,616,1,0,0,0,616,617,1,0,0,0,617,618,3,82,
  	41,0,618,619,5,2,0,0,619,81,1,0,0,0,620,639,3,14,7,0,621,622,3,98,49,
  	0,622,623,3,14,7,0,623,639,1,0,0,0,624,625,3,104,52,0,625,626,3,82,41,
  	0,626,639,1,0,0,0,627,628,3,6,3,0,628,629,5,1,0,0,629,633,5,52,0,0,630,
  	632,3,22,11,0,631,630,1,0,0,0,632,635,1,0,0,0,633,631,1,0,0,0,633,634,
  	1,0,0,0,634,636,1,0,0,0,635,633,1,0,0,0,636,637,5,2,0,0,637,639,1,0,0,
  	0,638,620,1,0,0,0,638,621,1,0,0,0,638,624,1,0,0,0,638,627,1,0,0,0,639,
  	83,1,0,0,0,640,641,5,1,0,0,641,643,5,53,0,0,642,644,3,22,11,0,643,642,
  	1,0,0,0,643,644,1,0,0,0,644,645,1,0,0,0,645,649,3,76,38,0,646,648,5,6,
  	0,0,647,646,1,0,0,0,648,651,1,0,0,0,649,647,1,0,0,0,649,650,1,0,0,0,650,
  	652,1,0,0,0,651,649,1,0,0,0,652,653,5,2,0,0,653,85,1,0,0,0,654,655,5,
  	1,0,0,655,657,5,51,0,0,656,658,3,24,12,0,657,656,1,0,0,0,657,658,1,0,
  	0,0,658,659,1,0,0,0,659,660,3,88,44,0,660,661,5,2,0,0,661,87,1,0,0,0,
  	662,679,3,16,8,0,663,664,3,98,49,0,664,665,3,16,8,0,665,679,1,0,0,0,666,
  	667,3,104,52,0,667,668,3,88,44,0,668,679,1,0,0,0,669,670,5,1,0,0,670,
  	674,5,53,0,0,671,673,5,6,0,0,672,671,1,0,0,0,673,676,1,0,0,0,674,672,
  	1,0,0,0,674,675,1,0,0,0,675,677,1,0,0,0,676,674,1,0,0,0,677,679,5,2,0,
  	0,678,662,1,0,0,0,678,663,1,0,0,0,678,666,1,0,0,0,678,669,1,0,0,0,679,
  	89,1,0,0,0,680,681,5,1,0,0,681,683,5,49,0,0,682,684,3,24,12,0,683,682,
  	1,0,0,0,683,684,1,0,0,0,684,685,1,0,0,0,685,686,3,92,46,0,686,687,5,2,
  	0,0,687,91,1,0,0,0,688,689,3,8,4,0,689,690,3,60,30,0,690,698,1,0,0,0,
  	691,692,3,98,49,0,692,693,3,8,4,0,693,698,1,0,0,0,694,695,3,104,52,0,
  	695,696,3,92,46,0,696,698,1,0,0,0,697,688,1,0,0,0,697,691,1,0,0,0,697,
  	694,1,0,0,0,698,93,1,0,0,0,699,700,5,1,0,0,700,702,5,44,0,0,701,703,3,
  	24,12,0,702,701,1,0,0,0,702,703,1,0,0,0,703,704,1,0,0,0,704,705,3,18,
  	9,0,705,706,5,2,0,0,706,740,1,0,0,0,707,708,5,1,0,0,708,710,5,44,0,0,
  	709,711,3,24,12,0,710,709,1,0,0,0,710,711,1,0,0,0,711,712,1,0,0,0,712,
  	713,3,12,6,0,713,714,5,2,0,0,714,740,1,0,0,0,715,716,5,1,0,0,716,718,
  	5,50,0,0,717,719,3,24,12,0,718,717,1,0,0,0,718,719,1,0,0,0,719,720,1,
  	0,0,0,720,721,3,14,7,0,721,722,5,2,0,0,722,740,1,0,0,0,723,724,5,1,0,
  	0,724,726,5,51,0,0,725,727,3,24,12,0,726,725,1,0,0,0,726,727,1,0,0,0,
  	727,728,1,0,0,0,728,729,3,16,8,0,729,730,5,2,0,0,730,740,1,0,0,0,731,
  	732,5,1,0,0,732,734,5,49,0,0,733,735,3,24,12,0,734,733,1,0,0,0,734,735,
  	1,0,0,0,735,736,1,0,0,0,736,737,3,8,4,0,737,738,5,2,0,0,738,740,1,0,0,
  	0,739,699,1,0,0,0,739,707,1,0,0,0,739,715,1,0,0,0,739,723,1,0,0,0,739,
  	731,1,0,0,0,740,95,1,0,0,0,741,742,5,1,0,0,742,743,5,55,0,0,743,744,3,
  	2,1,0,744,745,3,2,1,0,745,746,3,94,47,0,746,747,5,2,0,0,747,97,1,0,0,
  	0,748,749,5,1,0,0,749,750,5,55,0,0,750,751,3,2,1,0,751,752,3,2,1,0,752,
  	753,5,2,0,0,753,99,1,0,0,0,754,755,5,1,0,0,755,756,5,44,0,0,756,757,3,
  	22,11,0,757,758,5,2,0,0,758,775,1,0,0,0,759,760,5,1,0,0,760,761,5,50,
  	0,0,761,762,3,22,11,0,762,763,5,2,0,0,763,775,1,0,0,0,764,765,5,1,0,0,
  	765,766,5,51,0,0,766,767,3,22,11,0,767,768,5,2,0,0,768,775,1,0,0,0,769,
  	770,5,1,0,0,770,771,5,49,0,0,771,772,3,22,11,0,772,773,5,2,0,0,773,775,
  	1,0,0,0,774,754,1,0,0,0,774,759,1,0,0,0,774,764,1,0,0,0,774,769,1,0,0,
  	0,775,101,1,0,0,0,776,777,5,1,0,0,777,778,5,56,0,0,778,779,3,2,1,0,779,
  	780,3,100,50,0,780,781,5,2,0,0,781,103,1,0,0,0,782,783,5,1,0,0,783,784,
  	5,56,0,0,784,785,3,2,1,0,785,786,5,2,0,0,786,105,1,0,0,0,787,788,3,10,
  	5,0,788,107,1,0,0,0,789,790,5,1,0,0,790,792,5,43,0,0,791,793,3,24,12,
  	0,792,791,1,0,0,0,792,793,1,0,0,0,793,794,1,0,0,0,794,795,3,106,53,0,
  	795,796,5,2,0,0,796,109,1,0,0,0,797,798,5,1,0,0,798,799,5,45,0,0,799,
  	800,3,22,11,0,800,801,5,2,0,0,801,111,1,0,0,0,802,813,3,108,54,0,803,
  	813,3,90,45,0,804,813,3,80,40,0,805,813,3,86,43,0,806,813,3,62,31,0,807,
  	813,3,78,39,0,808,813,3,84,42,0,809,813,3,110,55,0,810,813,3,96,48,0,
  	811,813,3,102,51,0,812,802,1,0,0,0,812,803,1,0,0,0,812,804,1,0,0,0,812,
  	805,1,0,0,0,812,806,1,0,0,0,812,807,1,0,0,0,812,808,1,0,0,0,812,809,1,
  	0,0,0,812,810,1,0,0,0,812,811,1,0,0,0,813,113,1,0,0,0,814,815,5,1,0,0,
  	815,817,5,57,0,0,816,818,5,74,0,0,817,816,1,0,0,0,817,818,1,0,0,0,818,
  	822,1,0,0,0,819,821,3,112,56,0,820,819,1,0,0,0,821,824,1,0,0,0,822,820,
  	1,0,0,0,822,823,1,0,0,0,823,825,1,0,0,0,824,822,1,0,0,0,825,826,5,2,0,
  	0,826,115,1,0,0,0,827,842,3,114,57,0,828,829,5,1,0,0,829,831,5,57,0,0,
  	830,832,5,74,0,0,831,830,1,0,0,0,831,832,1,0,0,0,832,833,1,0,0,0,833,
  	837,7,4,0,0,834,836,5,6,0,0,835,834,1,0,0,0,836,839,1,0,0,0,837,835,1,
  	0,0,0,837,838,1,0,0,0,838,840,1,0,0,0,839,837,1,0,0,0,840,842,5,2,0,0,
  	841,827,1,0,0,0,841,828,1,0,0,0,842,117,1,0,0,0,843,844,5,1,0,0,844,846,
  	5,62,0,0,845,847,5,74,0,0,846,845,1,0,0,0,846,847,1,0,0,0,847,848,1,0,
  	0,0,848,849,3,2,1,0,849,850,3,128,64,0,850,851,5,2,0,0,851,861,1,0,0,
  	0,852,853,5,1,0,0,853,855,5,63,0,0,854,856,5,74,0,0,855,854,1,0,0,0,855,
  	856,1,0,0,0,856,857,1,0,0,0,857,858,3,2,1,0,858,859,5,2,0,0,859,861,1,
  	0,0,0,860,843,1,0,0,0,860,852,1,0,0,0,861,119,1,0,0,0,862,863,5,1,0,0,
  	863,864,5,64,0,0,864,865,3,116,58,0,865,866,5,6,0,0,866,867,5,2,0,0,867,
  	915,1,0,0,0,868,869,5,1,0,0,869,870,5,65,0,0,870,871,3,116,58,0,871,872,
  	5,6,0,0,872,873,5,2,0,0,873,915,1,0,0,0,874,875,5,1,0,0,875,876,5,66,
  	0,0,876,877,3,116,58,0,877,878,5,6,0,0,878,879,5,2,0,0,879,915,1,0,0,
  	0,880,881,5,1,0,0,881,882,5,70,0,0,882,883,3,116,58,0,883,884,5,6,0,0,
  	884,885,5,2,0,0,885,915,1,0,0,0,886,887,5,1,0,0,887,888,5,67,0,0,888,
  	889,3,118,59,0,889,890,3,128,64,0,890,891,5,2,0,0,891,915,1,0,0,0,892,
  	893,5,1,0,0,893,894,5,68,0,0,894,895,3,118,59,0,895,896,5,2,0,0,896,915,
  	1,0,0,0,897,898,5,1,0,0,898,899,5,69,0,0,899,900,3,118,59,0,900,901,5,
  	2,0,0,901,915,1,0,0,0,902,903,5,1,0,0,903,904,5,70,0,0,904,905,3,118,
  	59,0,905,906,5,6,0,0,906,907,5,2,0,0,907,915,1,0,0,0,908,909,5,1,0,0,
  	909,910,5,71,0,0,910,911,3,118,59,0,911,912,5,6,0,0,912,913,5,2,0,0,913,
  	915,1,0,0,0,914,862,1,0,0,0,914,868,1,0,0,0,914,874,1,0,0,0,914,880,1,
  	0,0,0,914,886,1,0,0,0,914,892,1,0,0,0,914,897,1,0,0,0,914,902,1,0,0,0,
  	914,908,1,0,0,0,915,121,1,0,0,0,916,929,3,118,59,0,917,929,3,120,60,0,
  	918,929,3,116,58,0,919,920,5,1,0,0,920,921,5,61,0,0,921,923,3,2,1,0,922,
  	924,5,74,0,0,923,922,1,0,0,0,923,924,1,0,0,0,924,925,1,0,0,0,925,926,
  	5,2,0,0,926,929,1,0,0,0,927,929,3,124,62,0,928,916,1,0,0,0,928,917,1,
  	0,0,0,928,918,1,0,0,0,928,919,1,0,0,0,928,927,1,0,0,0,929,123,1,0,0,0,
  	930,931,5,1,0,0,931,933,5,60,0,0,932,934,5,74,0,0,933,932,1,0,0,0,933,
  	934,1,0,0,0,934,938,1,0,0,0,935,937,3,122,61,0,936,935,1,0,0,0,937,940,
  	1,0,0,0,938,936,1,0,0,0,938,939,1,0,0,0,939,941,1,0,0,0,940,938,1,0,0,
  	0,941,963,5,2,0,0,942,943,5,1,0,0,943,945,5,72,0,0,944,946,5,74,0,0,945,
  	944,1,0,0,0,945,946,1,0,0,0,946,947,1,0,0,0,947,948,5,6,0,0,948,963,5,
  	2,0,0,949,950,5,1,0,0,950,952,5,73,0,0,951,953,5,74,0,0,952,951,1,0,0,
  	0,952,953,1,0,0,0,953,954,1,0,0,0,954,955,5,6,0,0,955,963,5,2,0,0,956,
  	957,5,1,0,0,957,959,5,73,0,0,958,960,5,74,0,0,959,958,1,0,0,0,959,960,
  	1,0,0,0,960,961,1,0,0,0,961,963,5,2,0,0,962,930,1,0,0,0,962,942,1,0,0,
  	0,962,949,1,0,0,0,962,956,1,0,0,0,963,125,1,0,0,0,964,965,5,1,0,0,965,
  	966,5,8,0,0,966,967,3,20,10,0,967,968,5,2,0,0,968,127,1,0,0,0,969,971,
  	3,126,63,0,970,969,1,0,0,0,971,974,1,0,0,0,972,970,1,0,0,0,972,973,1,
  	0,0,0,973,129,1,0,0,0,974,972,1,0,0,0,975,977,3,122,61,0,976,975,1,0,
  	0,0,977,980,1,0,0,0,978,976,1,0,0,0,978,979,1,0,0,0,979,981,1,0,0,0,980,
  	978,1,0,0,0,981,990,5,0,0,1,982,984,3,112,56,0,983,982,1,0,0,0,984,985,
  	1,0,0,0,985,983,1,0,0,0,985,986,1,0,0,0,986,987,1,0,0,0,987,988,5,0,0,
  	1,988,990,1,0,0,0,989,978,1,0,0,0,989,983,1,0,0,0,990,131,1,0,0,0,991,
  	992,3,114,57,0,992,993,5,0,0,1,993,1002,1,0,0,0,994,996,3,112,56,0,995,
  	994,1,0,0,0,996,999,1,0,0,0,997,995,1,0,0,0,997,998,1,0,0,0,998,1000,
  	1,0,0,0,999,997,1,0,0,0,1000,1002,5,0,0,1,1001,991,1,0,0,0,1001,997,1,
  	0,0,0,1002,133,1,0,0,0,109,148,160,167,174,179,184,190,207,221,238,241,
  	245,248,259,263,272,278,286,292,297,306,312,322,328,335,340,344,349,352,
  	356,358,366,378,385,390,395,398,401,410,416,426,432,438,447,459,461,466,
  	470,477,483,488,495,502,512,521,527,535,545,547,557,563,573,583,585,596,
  	601,607,615,633,638,643,649,657,674,678,683,697,702,710,718,726,734,739,
  	774,792,812,817,822,831,837,841,846,855,860,914,923,928,933,938,945,952,
  	959,962,972,978,985,989,997,1001
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  watparserParserStaticData = staticData.release();
}

}

WatParser::WatParser(TokenStream *input) : WatParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

WatParser::WatParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  WatParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *watparserParserStaticData->atn, watparserParserStaticData->decisionToDFA, watparserParserStaticData->sharedContextCache, options);
}

WatParser::~WatParser() {
  delete _interpreter;
}

const atn::ATN& WatParser::getATN() const {
  return *watparserParserStaticData->atn;
}

std::string WatParser::getGrammarFileName() const {
  return "WatParser.g4";
}

const std::vector<std::string>& WatParser::getRuleNames() const {
  return watparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& WatParser::getVocabulary() const {
  return watparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView WatParser::getSerializedATN() const {
  return watparserParserStaticData->serializedATN;
}


//----------------- ValueContext ------------------------------------------------------------------

WatParser::ValueContext::ValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::ValueContext::INT() {
  return getToken(WatParser::INT, 0);
}

tree::TerminalNode* WatParser::ValueContext::FLOAT() {
  return getToken(WatParser::FLOAT, 0);
}


size_t WatParser::ValueContext::getRuleIndex() const {
  return WatParser::RuleValue;
}

void WatParser::ValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValue(this);
}

void WatParser::ValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValue(this);
}


std::any WatParser::ValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitValue(this);
  else
    return visitor->visitChildren(this);
}

WatParser::ValueContext* WatParser::value() {
  ValueContext *_localctx = _tracker.createInstance<ValueContext>(_ctx, getState());
  enterRule(_localctx, 0, WatParser::RuleValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(134);
    _la = _input->LA(1);
    if (!(_la == WatParser::INT

    || _la == WatParser::FLOAT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameContext ------------------------------------------------------------------

WatParser::NameContext::NameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::NameContext::STRING_() {
  return getToken(WatParser::STRING_, 0);
}


size_t WatParser::NameContext::getRuleIndex() const {
  return WatParser::RuleName;
}

void WatParser::NameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterName(this);
}

void WatParser::NameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitName(this);
}


std::any WatParser::NameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitName(this);
  else
    return visitor->visitChildren(this);
}

WatParser::NameContext* WatParser::name() {
  NameContext *_localctx = _tracker.createInstance<NameContext>(_ctx, getState());
  enterRule(_localctx, 2, WatParser::RuleName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(136);
    match(WatParser::STRING_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Value_typeContext ------------------------------------------------------------------

WatParser::Value_typeContext::Value_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Value_typeContext::VALUE_TYPE() {
  return getToken(WatParser::VALUE_TYPE, 0);
}


size_t WatParser::Value_typeContext::getRuleIndex() const {
  return WatParser::RuleValue_type;
}

void WatParser::Value_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValue_type(this);
}

void WatParser::Value_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValue_type(this);
}


std::any WatParser::Value_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitValue_type(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Value_typeContext* WatParser::value_type() {
  Value_typeContext *_localctx = _tracker.createInstance<Value_typeContext>(_ctx, getState());
  enterRule(_localctx, 4, WatParser::RuleValue_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(138);
    match(WatParser::VALUE_TYPE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Elem_typeContext ------------------------------------------------------------------

WatParser::Elem_typeContext::Elem_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Elem_typeContext::FUNCREF() {
  return getToken(WatParser::FUNCREF, 0);
}


size_t WatParser::Elem_typeContext::getRuleIndex() const {
  return WatParser::RuleElem_type;
}

void WatParser::Elem_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElem_type(this);
}

void WatParser::Elem_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElem_type(this);
}


std::any WatParser::Elem_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitElem_type(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Elem_typeContext* WatParser::elem_type() {
  Elem_typeContext *_localctx = _tracker.createInstance<Elem_typeContext>(_ctx, getState());
  enterRule(_localctx, 6, WatParser::RuleElem_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(140);
    match(WatParser::FUNCREF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Global_typeContext ------------------------------------------------------------------

WatParser::Global_typeContext::Global_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Value_typeContext* WatParser::Global_typeContext::value_type() {
  return getRuleContext<WatParser::Value_typeContext>(0);
}

tree::TerminalNode* WatParser::Global_typeContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::Global_typeContext::MUT() {
  return getToken(WatParser::MUT, 0);
}

tree::TerminalNode* WatParser::Global_typeContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}


size_t WatParser::Global_typeContext::getRuleIndex() const {
  return WatParser::RuleGlobal_type;
}

void WatParser::Global_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGlobal_type(this);
}

void WatParser::Global_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGlobal_type(this);
}


std::any WatParser::Global_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitGlobal_type(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Global_typeContext* WatParser::global_type() {
  Global_typeContext *_localctx = _tracker.createInstance<Global_typeContext>(_ctx, getState());
  enterRule(_localctx, 8, WatParser::RuleGlobal_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(148);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case WatParser::VALUE_TYPE: {
        enterOuterAlt(_localctx, 1);
        setState(142);
        value_type();
        break;
      }

      case WatParser::LPAR: {
        enterOuterAlt(_localctx, 2);
        setState(143);
        match(WatParser::LPAR);
        setState(144);
        match(WatParser::MUT);
        setState(145);
        value_type();
        setState(146);
        match(WatParser::RPAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Def_typeContext ------------------------------------------------------------------

WatParser::Def_typeContext::Def_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Def_typeContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::Def_typeContext::FUNC() {
  return getToken(WatParser::FUNC, 0);
}

WatParser::Func_typeContext* WatParser::Def_typeContext::func_type() {
  return getRuleContext<WatParser::Func_typeContext>(0);
}

tree::TerminalNode* WatParser::Def_typeContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}


size_t WatParser::Def_typeContext::getRuleIndex() const {
  return WatParser::RuleDef_type;
}

void WatParser::Def_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDef_type(this);
}

void WatParser::Def_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDef_type(this);
}


std::any WatParser::Def_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitDef_type(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Def_typeContext* WatParser::def_type() {
  Def_typeContext *_localctx = _tracker.createInstance<Def_typeContext>(_ctx, getState());
  enterRule(_localctx, 10, WatParser::RuleDef_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(150);
    match(WatParser::LPAR);
    setState(151);
    match(WatParser::FUNC);
    setState(152);
    func_type();
    setState(153);
    match(WatParser::RPAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_typeContext ------------------------------------------------------------------

WatParser::Func_typeContext::Func_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> WatParser::Func_typeContext::LPAR() {
  return getTokens(WatParser::LPAR);
}

tree::TerminalNode* WatParser::Func_typeContext::LPAR(size_t i) {
  return getToken(WatParser::LPAR, i);
}

std::vector<tree::TerminalNode *> WatParser::Func_typeContext::RPAR() {
  return getTokens(WatParser::RPAR);
}

tree::TerminalNode* WatParser::Func_typeContext::RPAR(size_t i) {
  return getToken(WatParser::RPAR, i);
}

std::vector<tree::TerminalNode *> WatParser::Func_typeContext::RESULT() {
  return getTokens(WatParser::RESULT);
}

tree::TerminalNode* WatParser::Func_typeContext::RESULT(size_t i) {
  return getToken(WatParser::RESULT, i);
}

std::vector<tree::TerminalNode *> WatParser::Func_typeContext::PARAM() {
  return getTokens(WatParser::PARAM);
}

tree::TerminalNode* WatParser::Func_typeContext::PARAM(size_t i) {
  return getToken(WatParser::PARAM, i);
}

std::vector<WatParser::Bind_varContext *> WatParser::Func_typeContext::bind_var() {
  return getRuleContexts<WatParser::Bind_varContext>();
}

WatParser::Bind_varContext* WatParser::Func_typeContext::bind_var(size_t i) {
  return getRuleContext<WatParser::Bind_varContext>(i);
}

std::vector<WatParser::Value_typeContext *> WatParser::Func_typeContext::value_type() {
  return getRuleContexts<WatParser::Value_typeContext>();
}

WatParser::Value_typeContext* WatParser::Func_typeContext::value_type(size_t i) {
  return getRuleContext<WatParser::Value_typeContext>(i);
}


size_t WatParser::Func_typeContext::getRuleIndex() const {
  return WatParser::RuleFunc_type;
}

void WatParser::Func_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_type(this);
}

void WatParser::Func_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_type(this);
}


std::any WatParser::Func_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitFunc_type(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Func_typeContext* WatParser::func_type() {
  Func_typeContext *_localctx = _tracker.createInstance<Func_typeContext>(_ctx, getState());
  enterRule(_localctx, 12, WatParser::RuleFunc_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(179);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == WatParser::LPAR) {
      setState(155);
      match(WatParser::LPAR);
      setState(174);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx)) {
      case 1: {
        setState(156);
        match(WatParser::RESULT);
        setState(160);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == WatParser::VALUE_TYPE) {
          setState(157);
          value_type();
          setState(162);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case 2: {
        setState(163);
        match(WatParser::PARAM);
        setState(167);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == WatParser::VALUE_TYPE) {
          setState(164);
          value_type();
          setState(169);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case 3: {
        setState(170);
        match(WatParser::PARAM);
        setState(171);
        bind_var();
        setState(172);
        value_type();
        break;
      }

      default:
        break;
      }
      setState(176);
      match(WatParser::RPAR);
      setState(181);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_typeContext ------------------------------------------------------------------

WatParser::Table_typeContext::Table_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> WatParser::Table_typeContext::NAT() {
  return getTokens(WatParser::NAT);
}

tree::TerminalNode* WatParser::Table_typeContext::NAT(size_t i) {
  return getToken(WatParser::NAT, i);
}

WatParser::Elem_typeContext* WatParser::Table_typeContext::elem_type() {
  return getRuleContext<WatParser::Elem_typeContext>(0);
}


size_t WatParser::Table_typeContext::getRuleIndex() const {
  return WatParser::RuleTable_type;
}

void WatParser::Table_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_type(this);
}

void WatParser::Table_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_type(this);
}


std::any WatParser::Table_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitTable_type(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Table_typeContext* WatParser::table_type() {
  Table_typeContext *_localctx = _tracker.createInstance<Table_typeContext>(_ctx, getState());
  enterRule(_localctx, 14, WatParser::RuleTable_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(182);
    match(WatParser::NAT);
    setState(184);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == WatParser::NAT) {
      setState(183);
      match(WatParser::NAT);
    }
    setState(186);
    elem_type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Memory_typeContext ------------------------------------------------------------------

WatParser::Memory_typeContext::Memory_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> WatParser::Memory_typeContext::NAT() {
  return getTokens(WatParser::NAT);
}

tree::TerminalNode* WatParser::Memory_typeContext::NAT(size_t i) {
  return getToken(WatParser::NAT, i);
}


size_t WatParser::Memory_typeContext::getRuleIndex() const {
  return WatParser::RuleMemory_type;
}

void WatParser::Memory_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemory_type(this);
}

void WatParser::Memory_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemory_type(this);
}


std::any WatParser::Memory_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitMemory_type(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Memory_typeContext* WatParser::memory_type() {
  Memory_typeContext *_localctx = _tracker.createInstance<Memory_typeContext>(_ctx, getState());
  enterRule(_localctx, 16, WatParser::RuleMemory_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(188);
    match(WatParser::NAT);
    setState(190);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == WatParser::NAT) {
      setState(189);
      match(WatParser::NAT);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_useContext ------------------------------------------------------------------

WatParser::Type_useContext::Type_useContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Type_useContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::Type_useContext::TYPE() {
  return getToken(WatParser::TYPE, 0);
}

WatParser::Var_Context* WatParser::Type_useContext::var_() {
  return getRuleContext<WatParser::Var_Context>(0);
}

tree::TerminalNode* WatParser::Type_useContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}


size_t WatParser::Type_useContext::getRuleIndex() const {
  return WatParser::RuleType_use;
}

void WatParser::Type_useContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_use(this);
}

void WatParser::Type_useContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_use(this);
}


std::any WatParser::Type_useContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitType_use(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Type_useContext* WatParser::type_use() {
  Type_useContext *_localctx = _tracker.createInstance<Type_useContext>(_ctx, getState());
  enterRule(_localctx, 18, WatParser::RuleType_use);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(192);
    match(WatParser::LPAR);
    setState(193);
    match(WatParser::TYPE);
    setState(194);
    var_();
    setState(195);
    match(WatParser::RPAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

WatParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::LiteralContext::NAT() {
  return getToken(WatParser::NAT, 0);
}

tree::TerminalNode* WatParser::LiteralContext::INT() {
  return getToken(WatParser::INT, 0);
}

tree::TerminalNode* WatParser::LiteralContext::FLOAT() {
  return getToken(WatParser::FLOAT, 0);
}


size_t WatParser::LiteralContext::getRuleIndex() const {
  return WatParser::RuleLiteral;
}

void WatParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void WatParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}


std::any WatParser::LiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitLiteral(this);
  else
    return visitor->visitChildren(this);
}

WatParser::LiteralContext* WatParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 20, WatParser::RuleLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(197);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 56) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Var_Context ------------------------------------------------------------------

WatParser::Var_Context::Var_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Var_Context::NAT() {
  return getToken(WatParser::NAT, 0);
}

tree::TerminalNode* WatParser::Var_Context::VAR() {
  return getToken(WatParser::VAR, 0);
}


size_t WatParser::Var_Context::getRuleIndex() const {
  return WatParser::RuleVar_;
}

void WatParser::Var_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVar_(this);
}

void WatParser::Var_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVar_(this);
}


std::any WatParser::Var_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitVar_(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Var_Context* WatParser::var_() {
  Var_Context *_localctx = _tracker.createInstance<Var_Context>(_ctx, getState());
  enterRule(_localctx, 22, WatParser::RuleVar_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(199);
    _la = _input->LA(1);
    if (!(_la == WatParser::NAT || _la == WatParser::VAR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bind_varContext ------------------------------------------------------------------

WatParser::Bind_varContext::Bind_varContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Bind_varContext::VAR() {
  return getToken(WatParser::VAR, 0);
}


size_t WatParser::Bind_varContext::getRuleIndex() const {
  return WatParser::RuleBind_var;
}

void WatParser::Bind_varContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBind_var(this);
}

void WatParser::Bind_varContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBind_var(this);
}


std::any WatParser::Bind_varContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitBind_var(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Bind_varContext* WatParser::bind_var() {
  Bind_varContext *_localctx = _tracker.createInstance<Bind_varContext>(_ctx, getState());
  enterRule(_localctx, 24, WatParser::RuleBind_var);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(201);
    match(WatParser::VAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InstrContext ------------------------------------------------------------------

WatParser::InstrContext::InstrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Plain_instrContext* WatParser::InstrContext::plain_instr() {
  return getRuleContext<WatParser::Plain_instrContext>(0);
}

WatParser::Call_instr_instrContext* WatParser::InstrContext::call_instr_instr() {
  return getRuleContext<WatParser::Call_instr_instrContext>(0);
}

WatParser::Block_instrContext* WatParser::InstrContext::block_instr() {
  return getRuleContext<WatParser::Block_instrContext>(0);
}

WatParser::ExprContext* WatParser::InstrContext::expr() {
  return getRuleContext<WatParser::ExprContext>(0);
}


size_t WatParser::InstrContext::getRuleIndex() const {
  return WatParser::RuleInstr;
}

void WatParser::InstrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInstr(this);
}

void WatParser::InstrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInstr(this);
}


std::any WatParser::InstrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitInstr(this);
  else
    return visitor->visitChildren(this);
}

WatParser::InstrContext* WatParser::instr() {
  InstrContext *_localctx = _tracker.createInstance<InstrContext>(_ctx, getState());
  enterRule(_localctx, 26, WatParser::RuleInstr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(207);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case WatParser::CONST:
      case WatParser::NOP:
      case WatParser::UNREACHABLE:
      case WatParser::DROP:
      case WatParser::BR:
      case WatParser::BR_IF:
      case WatParser::BR_TABLE:
      case WatParser::RETURN:
      case WatParser::SELECT:
      case WatParser::CALL:
      case WatParser::LOCAL_GET:
      case WatParser::LOCAL_SET:
      case WatParser::LOCAL_TEE:
      case WatParser::GLOBAL_GET:
      case WatParser::GLOBAL_SET:
      case WatParser::LOAD:
      case WatParser::STORE:
      case WatParser::UNARY:
      case WatParser::BINARY:
      case WatParser::TEST:
      case WatParser::COMPARE:
      case WatParser::CONVERT:
      case WatParser::MEMORY_SIZE:
      case WatParser::MEMORY_GROW: {
        enterOuterAlt(_localctx, 1);
        setState(203);
        plain_instr();
        break;
      }

      case WatParser::CALL_INDIRECT: {
        enterOuterAlt(_localctx, 2);
        setState(204);
        call_instr_instr();
        break;
      }

      case WatParser::BLOCK:
      case WatParser::LOOP:
      case WatParser::IF: {
        enterOuterAlt(_localctx, 3);
        setState(205);
        block_instr();
        break;
      }

      case WatParser::LPAR: {
        enterOuterAlt(_localctx, 4);
        setState(206);
        expr();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plain_instrContext ------------------------------------------------------------------

WatParser::Plain_instrContext::Plain_instrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Plain_instrContext::UNREACHABLE() {
  return getToken(WatParser::UNREACHABLE, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::NOP() {
  return getToken(WatParser::NOP, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::DROP() {
  return getToken(WatParser::DROP, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::SELECT() {
  return getToken(WatParser::SELECT, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::BR() {
  return getToken(WatParser::BR, 0);
}

std::vector<WatParser::Var_Context *> WatParser::Plain_instrContext::var_() {
  return getRuleContexts<WatParser::Var_Context>();
}

WatParser::Var_Context* WatParser::Plain_instrContext::var_(size_t i) {
  return getRuleContext<WatParser::Var_Context>(i);
}

tree::TerminalNode* WatParser::Plain_instrContext::BR_IF() {
  return getToken(WatParser::BR_IF, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::BR_TABLE() {
  return getToken(WatParser::BR_TABLE, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::RETURN() {
  return getToken(WatParser::RETURN, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::CALL() {
  return getToken(WatParser::CALL, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::LOCAL_GET() {
  return getToken(WatParser::LOCAL_GET, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::LOCAL_SET() {
  return getToken(WatParser::LOCAL_SET, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::LOCAL_TEE() {
  return getToken(WatParser::LOCAL_TEE, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::GLOBAL_GET() {
  return getToken(WatParser::GLOBAL_GET, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::GLOBAL_SET() {
  return getToken(WatParser::GLOBAL_SET, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::LOAD() {
  return getToken(WatParser::LOAD, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::OFFSET_EQ_NAT() {
  return getToken(WatParser::OFFSET_EQ_NAT, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::ALIGN_EQ_NAT() {
  return getToken(WatParser::ALIGN_EQ_NAT, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::STORE() {
  return getToken(WatParser::STORE, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::MEMORY_SIZE() {
  return getToken(WatParser::MEMORY_SIZE, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::MEMORY_GROW() {
  return getToken(WatParser::MEMORY_GROW, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::CONST() {
  return getToken(WatParser::CONST, 0);
}

WatParser::LiteralContext* WatParser::Plain_instrContext::literal() {
  return getRuleContext<WatParser::LiteralContext>(0);
}

tree::TerminalNode* WatParser::Plain_instrContext::TEST() {
  return getToken(WatParser::TEST, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::COMPARE() {
  return getToken(WatParser::COMPARE, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::UNARY() {
  return getToken(WatParser::UNARY, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::BINARY() {
  return getToken(WatParser::BINARY, 0);
}

tree::TerminalNode* WatParser::Plain_instrContext::CONVERT() {
  return getToken(WatParser::CONVERT, 0);
}


size_t WatParser::Plain_instrContext::getRuleIndex() const {
  return WatParser::RulePlain_instr;
}

void WatParser::Plain_instrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlain_instr(this);
}

void WatParser::Plain_instrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlain_instr(this);
}


std::any WatParser::Plain_instrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitPlain_instr(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Plain_instrContext* WatParser::plain_instr() {
  Plain_instrContext *_localctx = _tracker.createInstance<Plain_instrContext>(_ctx, getState());
  enterRule(_localctx, 28, WatParser::RulePlain_instr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(259);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case WatParser::UNREACHABLE: {
        enterOuterAlt(_localctx, 1);
        setState(209);
        match(WatParser::UNREACHABLE);
        break;
      }

      case WatParser::NOP: {
        enterOuterAlt(_localctx, 2);
        setState(210);
        match(WatParser::NOP);
        break;
      }

      case WatParser::DROP: {
        enterOuterAlt(_localctx, 3);
        setState(211);
        match(WatParser::DROP);
        break;
      }

      case WatParser::SELECT: {
        enterOuterAlt(_localctx, 4);
        setState(212);
        match(WatParser::SELECT);
        break;
      }

      case WatParser::BR: {
        enterOuterAlt(_localctx, 5);
        setState(213);
        match(WatParser::BR);
        setState(214);
        var_();
        break;
      }

      case WatParser::BR_IF: {
        enterOuterAlt(_localctx, 6);
        setState(215);
        match(WatParser::BR_IF);
        setState(216);
        var_();
        break;
      }

      case WatParser::BR_TABLE: {
        enterOuterAlt(_localctx, 7);
        setState(217);
        match(WatParser::BR_TABLE);
        setState(219); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(218);
          var_();
          setState(221); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == WatParser::NAT || _la == WatParser::VAR);
        break;
      }

      case WatParser::RETURN: {
        enterOuterAlt(_localctx, 8);
        setState(223);
        match(WatParser::RETURN);
        break;
      }

      case WatParser::CALL: {
        enterOuterAlt(_localctx, 9);
        setState(224);
        match(WatParser::CALL);
        setState(225);
        var_();
        break;
      }

      case WatParser::LOCAL_GET: {
        enterOuterAlt(_localctx, 10);
        setState(226);
        match(WatParser::LOCAL_GET);
        setState(227);
        var_();
        break;
      }

      case WatParser::LOCAL_SET: {
        enterOuterAlt(_localctx, 11);
        setState(228);
        match(WatParser::LOCAL_SET);
        setState(229);
        var_();
        break;
      }

      case WatParser::LOCAL_TEE: {
        enterOuterAlt(_localctx, 12);
        setState(230);
        match(WatParser::LOCAL_TEE);
        setState(231);
        var_();
        break;
      }

      case WatParser::GLOBAL_GET: {
        enterOuterAlt(_localctx, 13);
        setState(232);
        match(WatParser::GLOBAL_GET);
        setState(233);
        var_();
        break;
      }

      case WatParser::GLOBAL_SET: {
        enterOuterAlt(_localctx, 14);
        setState(234);
        match(WatParser::GLOBAL_SET);
        setState(235);
        var_();
        break;
      }

      case WatParser::LOAD: {
        enterOuterAlt(_localctx, 15);
        setState(236);
        match(WatParser::LOAD);
        setState(238);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WatParser::OFFSET_EQ_NAT) {
          setState(237);
          match(WatParser::OFFSET_EQ_NAT);
        }
        setState(241);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WatParser::ALIGN_EQ_NAT) {
          setState(240);
          match(WatParser::ALIGN_EQ_NAT);
        }
        break;
      }

      case WatParser::STORE: {
        enterOuterAlt(_localctx, 16);
        setState(243);
        match(WatParser::STORE);
        setState(245);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WatParser::OFFSET_EQ_NAT) {
          setState(244);
          match(WatParser::OFFSET_EQ_NAT);
        }
        setState(248);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WatParser::ALIGN_EQ_NAT) {
          setState(247);
          match(WatParser::ALIGN_EQ_NAT);
        }
        break;
      }

      case WatParser::MEMORY_SIZE: {
        enterOuterAlt(_localctx, 17);
        setState(250);
        match(WatParser::MEMORY_SIZE);
        break;
      }

      case WatParser::MEMORY_GROW: {
        enterOuterAlt(_localctx, 18);
        setState(251);
        match(WatParser::MEMORY_GROW);
        break;
      }

      case WatParser::CONST: {
        enterOuterAlt(_localctx, 19);
        setState(252);
        match(WatParser::CONST);
        setState(253);
        literal();
        break;
      }

      case WatParser::TEST: {
        enterOuterAlt(_localctx, 20);
        setState(254);
        match(WatParser::TEST);
        break;
      }

      case WatParser::COMPARE: {
        enterOuterAlt(_localctx, 21);
        setState(255);
        match(WatParser::COMPARE);
        break;
      }

      case WatParser::UNARY: {
        enterOuterAlt(_localctx, 22);
        setState(256);
        match(WatParser::UNARY);
        break;
      }

      case WatParser::BINARY: {
        enterOuterAlt(_localctx, 23);
        setState(257);
        match(WatParser::BINARY);
        break;
      }

      case WatParser::CONVERT: {
        enterOuterAlt(_localctx, 24);
        setState(258);
        match(WatParser::CONVERT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Call_instrContext ------------------------------------------------------------------

WatParser::Call_instrContext::Call_instrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Call_instrContext::CALL_INDIRECT() {
  return getToken(WatParser::CALL_INDIRECT, 0);
}

WatParser::Call_instr_paramsContext* WatParser::Call_instrContext::call_instr_params() {
  return getRuleContext<WatParser::Call_instr_paramsContext>(0);
}

WatParser::Type_useContext* WatParser::Call_instrContext::type_use() {
  return getRuleContext<WatParser::Type_useContext>(0);
}


size_t WatParser::Call_instrContext::getRuleIndex() const {
  return WatParser::RuleCall_instr;
}

void WatParser::Call_instrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCall_instr(this);
}

void WatParser::Call_instrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCall_instr(this);
}


std::any WatParser::Call_instrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitCall_instr(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Call_instrContext* WatParser::call_instr() {
  Call_instrContext *_localctx = _tracker.createInstance<Call_instrContext>(_ctx, getState());
  enterRule(_localctx, 30, WatParser::RuleCall_instr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(261);
    match(WatParser::CALL_INDIRECT);
    setState(263);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
    case 1: {
      setState(262);
      type_use();
      break;
    }

    default:
      break;
    }
    setState(265);
    call_instr_params();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Call_instr_paramsContext ------------------------------------------------------------------

WatParser::Call_instr_paramsContext::Call_instr_paramsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> WatParser::Call_instr_paramsContext::LPAR() {
  return getTokens(WatParser::LPAR);
}

tree::TerminalNode* WatParser::Call_instr_paramsContext::LPAR(size_t i) {
  return getToken(WatParser::LPAR, i);
}

std::vector<tree::TerminalNode *> WatParser::Call_instr_paramsContext::PARAM() {
  return getTokens(WatParser::PARAM);
}

tree::TerminalNode* WatParser::Call_instr_paramsContext::PARAM(size_t i) {
  return getToken(WatParser::PARAM, i);
}

std::vector<tree::TerminalNode *> WatParser::Call_instr_paramsContext::RPAR() {
  return getTokens(WatParser::RPAR);
}

tree::TerminalNode* WatParser::Call_instr_paramsContext::RPAR(size_t i) {
  return getToken(WatParser::RPAR, i);
}

std::vector<tree::TerminalNode *> WatParser::Call_instr_paramsContext::RESULT() {
  return getTokens(WatParser::RESULT);
}

tree::TerminalNode* WatParser::Call_instr_paramsContext::RESULT(size_t i) {
  return getToken(WatParser::RESULT, i);
}

std::vector<WatParser::Value_typeContext *> WatParser::Call_instr_paramsContext::value_type() {
  return getRuleContexts<WatParser::Value_typeContext>();
}

WatParser::Value_typeContext* WatParser::Call_instr_paramsContext::value_type(size_t i) {
  return getRuleContext<WatParser::Value_typeContext>(i);
}


size_t WatParser::Call_instr_paramsContext::getRuleIndex() const {
  return WatParser::RuleCall_instr_params;
}

void WatParser::Call_instr_paramsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCall_instr_params(this);
}

void WatParser::Call_instr_paramsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCall_instr_params(this);
}


std::any WatParser::Call_instr_paramsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitCall_instr_params(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Call_instr_paramsContext* WatParser::call_instr_params() {
  Call_instr_paramsContext *_localctx = _tracker.createInstance<Call_instr_paramsContext>(_ctx, getState());
  enterRule(_localctx, 32, WatParser::RuleCall_instr_params);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(278);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(267);
        match(WatParser::LPAR);
        setState(268);
        match(WatParser::PARAM);
        setState(272);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == WatParser::VALUE_TYPE) {
          setState(269);
          value_type();
          setState(274);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(275);
        match(WatParser::RPAR); 
      }
      setState(280);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx);
    }
    setState(292);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == WatParser::LPAR) {
      setState(281);
      match(WatParser::LPAR);
      setState(282);
      match(WatParser::RESULT);
      setState(286);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WatParser::VALUE_TYPE) {
        setState(283);
        value_type();
        setState(288);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(289);
      match(WatParser::RPAR);
      setState(294);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Call_instr_instrContext ------------------------------------------------------------------

WatParser::Call_instr_instrContext::Call_instr_instrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Call_instr_instrContext::CALL_INDIRECT() {
  return getToken(WatParser::CALL_INDIRECT, 0);
}

WatParser::Call_instr_params_instrContext* WatParser::Call_instr_instrContext::call_instr_params_instr() {
  return getRuleContext<WatParser::Call_instr_params_instrContext>(0);
}

WatParser::Type_useContext* WatParser::Call_instr_instrContext::type_use() {
  return getRuleContext<WatParser::Type_useContext>(0);
}


size_t WatParser::Call_instr_instrContext::getRuleIndex() const {
  return WatParser::RuleCall_instr_instr;
}

void WatParser::Call_instr_instrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCall_instr_instr(this);
}

void WatParser::Call_instr_instrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCall_instr_instr(this);
}


std::any WatParser::Call_instr_instrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitCall_instr_instr(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Call_instr_instrContext* WatParser::call_instr_instr() {
  Call_instr_instrContext *_localctx = _tracker.createInstance<Call_instr_instrContext>(_ctx, getState());
  enterRule(_localctx, 34, WatParser::RuleCall_instr_instr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(295);
    match(WatParser::CALL_INDIRECT);
    setState(297);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
    case 1: {
      setState(296);
      type_use();
      break;
    }

    default:
      break;
    }
    setState(299);
    call_instr_params_instr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Call_instr_params_instrContext ------------------------------------------------------------------

WatParser::Call_instr_params_instrContext::Call_instr_params_instrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Call_instr_results_instrContext* WatParser::Call_instr_params_instrContext::call_instr_results_instr() {
  return getRuleContext<WatParser::Call_instr_results_instrContext>(0);
}

std::vector<tree::TerminalNode *> WatParser::Call_instr_params_instrContext::LPAR() {
  return getTokens(WatParser::LPAR);
}

tree::TerminalNode* WatParser::Call_instr_params_instrContext::LPAR(size_t i) {
  return getToken(WatParser::LPAR, i);
}

std::vector<tree::TerminalNode *> WatParser::Call_instr_params_instrContext::PARAM() {
  return getTokens(WatParser::PARAM);
}

tree::TerminalNode* WatParser::Call_instr_params_instrContext::PARAM(size_t i) {
  return getToken(WatParser::PARAM, i);
}

std::vector<tree::TerminalNode *> WatParser::Call_instr_params_instrContext::RPAR() {
  return getTokens(WatParser::RPAR);
}

tree::TerminalNode* WatParser::Call_instr_params_instrContext::RPAR(size_t i) {
  return getToken(WatParser::RPAR, i);
}

std::vector<WatParser::Value_typeContext *> WatParser::Call_instr_params_instrContext::value_type() {
  return getRuleContexts<WatParser::Value_typeContext>();
}

WatParser::Value_typeContext* WatParser::Call_instr_params_instrContext::value_type(size_t i) {
  return getRuleContext<WatParser::Value_typeContext>(i);
}


size_t WatParser::Call_instr_params_instrContext::getRuleIndex() const {
  return WatParser::RuleCall_instr_params_instr;
}

void WatParser::Call_instr_params_instrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCall_instr_params_instr(this);
}

void WatParser::Call_instr_params_instrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCall_instr_params_instr(this);
}


std::any WatParser::Call_instr_params_instrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitCall_instr_params_instr(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Call_instr_params_instrContext* WatParser::call_instr_params_instr() {
  Call_instr_params_instrContext *_localctx = _tracker.createInstance<Call_instr_params_instrContext>(_ctx, getState());
  enterRule(_localctx, 36, WatParser::RuleCall_instr_params_instr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(312);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(301);
        match(WatParser::LPAR);
        setState(302);
        match(WatParser::PARAM);
        setState(306);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == WatParser::VALUE_TYPE) {
          setState(303);
          value_type();
          setState(308);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(309);
        match(WatParser::RPAR); 
      }
      setState(314);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx);
    }
    setState(315);
    call_instr_results_instr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Call_instr_results_instrContext ------------------------------------------------------------------

WatParser::Call_instr_results_instrContext::Call_instr_results_instrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::InstrContext* WatParser::Call_instr_results_instrContext::instr() {
  return getRuleContext<WatParser::InstrContext>(0);
}

std::vector<tree::TerminalNode *> WatParser::Call_instr_results_instrContext::LPAR() {
  return getTokens(WatParser::LPAR);
}

tree::TerminalNode* WatParser::Call_instr_results_instrContext::LPAR(size_t i) {
  return getToken(WatParser::LPAR, i);
}

std::vector<tree::TerminalNode *> WatParser::Call_instr_results_instrContext::RESULT() {
  return getTokens(WatParser::RESULT);
}

tree::TerminalNode* WatParser::Call_instr_results_instrContext::RESULT(size_t i) {
  return getToken(WatParser::RESULT, i);
}

std::vector<tree::TerminalNode *> WatParser::Call_instr_results_instrContext::RPAR() {
  return getTokens(WatParser::RPAR);
}

tree::TerminalNode* WatParser::Call_instr_results_instrContext::RPAR(size_t i) {
  return getToken(WatParser::RPAR, i);
}

std::vector<WatParser::Value_typeContext *> WatParser::Call_instr_results_instrContext::value_type() {
  return getRuleContexts<WatParser::Value_typeContext>();
}

WatParser::Value_typeContext* WatParser::Call_instr_results_instrContext::value_type(size_t i) {
  return getRuleContext<WatParser::Value_typeContext>(i);
}


size_t WatParser::Call_instr_results_instrContext::getRuleIndex() const {
  return WatParser::RuleCall_instr_results_instr;
}

void WatParser::Call_instr_results_instrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCall_instr_results_instr(this);
}

void WatParser::Call_instr_results_instrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCall_instr_results_instr(this);
}


std::any WatParser::Call_instr_results_instrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitCall_instr_results_instr(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Call_instr_results_instrContext* WatParser::call_instr_results_instr() {
  Call_instr_results_instrContext *_localctx = _tracker.createInstance<Call_instr_results_instrContext>(_ctx, getState());
  enterRule(_localctx, 38, WatParser::RuleCall_instr_results_instr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(328);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(317);
        match(WatParser::LPAR);
        setState(318);
        match(WatParser::RESULT);
        setState(322);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == WatParser::VALUE_TYPE) {
          setState(319);
          value_type();
          setState(324);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(325);
        match(WatParser::RPAR); 
      }
      setState(330);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    }
    setState(331);
    instr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_instrContext ------------------------------------------------------------------

WatParser::Block_instrContext::Block_instrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::BlockContext* WatParser::Block_instrContext::block() {
  return getRuleContext<WatParser::BlockContext>(0);
}

tree::TerminalNode* WatParser::Block_instrContext::END() {
  return getToken(WatParser::END, 0);
}

tree::TerminalNode* WatParser::Block_instrContext::BLOCK() {
  return getToken(WatParser::BLOCK, 0);
}

tree::TerminalNode* WatParser::Block_instrContext::LOOP() {
  return getToken(WatParser::LOOP, 0);
}

std::vector<WatParser::Bind_varContext *> WatParser::Block_instrContext::bind_var() {
  return getRuleContexts<WatParser::Bind_varContext>();
}

WatParser::Bind_varContext* WatParser::Block_instrContext::bind_var(size_t i) {
  return getRuleContext<WatParser::Bind_varContext>(i);
}

tree::TerminalNode* WatParser::Block_instrContext::IF() {
  return getToken(WatParser::IF, 0);
}

tree::TerminalNode* WatParser::Block_instrContext::ELSE() {
  return getToken(WatParser::ELSE, 0);
}

WatParser::Instr_listContext* WatParser::Block_instrContext::instr_list() {
  return getRuleContext<WatParser::Instr_listContext>(0);
}


size_t WatParser::Block_instrContext::getRuleIndex() const {
  return WatParser::RuleBlock_instr;
}

void WatParser::Block_instrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock_instr(this);
}

void WatParser::Block_instrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock_instr(this);
}


std::any WatParser::Block_instrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitBlock_instr(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Block_instrContext* WatParser::block_instr() {
  Block_instrContext *_localctx = _tracker.createInstance<Block_instrContext>(_ctx, getState());
  enterRule(_localctx, 40, WatParser::RuleBlock_instr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(358);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case WatParser::BLOCK:
      case WatParser::LOOP: {
        enterOuterAlt(_localctx, 1);
        setState(333);
        _la = _input->LA(1);
        if (!(_la == WatParser::BLOCK

        || _la == WatParser::LOOP)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(335);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WatParser::VAR) {
          setState(334);
          bind_var();
        }
        setState(337);
        block();
        setState(338);
        match(WatParser::END);
        setState(340);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WatParser::VAR) {
          setState(339);
          bind_var();
        }
        break;
      }

      case WatParser::IF: {
        enterOuterAlt(_localctx, 2);
        setState(342);
        match(WatParser::IF);
        setState(344);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WatParser::VAR) {
          setState(343);
          bind_var();
        }
        setState(346);
        block();
        setState(352);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WatParser::ELSE) {
          setState(347);
          match(WatParser::ELSE);
          setState(349);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == WatParser::VAR) {
            setState(348);
            bind_var();
          }
          setState(351);
          instr_list();
        }
        setState(354);
        match(WatParser::END);
        setState(356);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WatParser::VAR) {
          setState(355);
          bind_var();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_typeContext ------------------------------------------------------------------

WatParser::Block_typeContext::Block_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Block_typeContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::Block_typeContext::RESULT() {
  return getToken(WatParser::RESULT, 0);
}

WatParser::Value_typeContext* WatParser::Block_typeContext::value_type() {
  return getRuleContext<WatParser::Value_typeContext>(0);
}

tree::TerminalNode* WatParser::Block_typeContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}


size_t WatParser::Block_typeContext::getRuleIndex() const {
  return WatParser::RuleBlock_type;
}

void WatParser::Block_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock_type(this);
}

void WatParser::Block_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock_type(this);
}


std::any WatParser::Block_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitBlock_type(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Block_typeContext* WatParser::block_type() {
  Block_typeContext *_localctx = _tracker.createInstance<Block_typeContext>(_ctx, getState());
  enterRule(_localctx, 42, WatParser::RuleBlock_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(360);
    match(WatParser::LPAR);
    setState(361);
    match(WatParser::RESULT);
    setState(362);
    value_type();
    setState(363);
    match(WatParser::RPAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

WatParser::BlockContext::BlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Instr_listContext* WatParser::BlockContext::instr_list() {
  return getRuleContext<WatParser::Instr_listContext>(0);
}

WatParser::Block_typeContext* WatParser::BlockContext::block_type() {
  return getRuleContext<WatParser::Block_typeContext>(0);
}


size_t WatParser::BlockContext::getRuleIndex() const {
  return WatParser::RuleBlock;
}

void WatParser::BlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock(this);
}

void WatParser::BlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock(this);
}


std::any WatParser::BlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitBlock(this);
  else
    return visitor->visitChildren(this);
}

WatParser::BlockContext* WatParser::block() {
  BlockContext *_localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 44, WatParser::RuleBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(366);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
    case 1: {
      setState(365);
      block_type();
      break;
    }

    default:
      break;
    }
    setState(368);
    instr_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprContext ------------------------------------------------------------------

WatParser::ExprContext::ExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::ExprContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

WatParser::Expr1Context* WatParser::ExprContext::expr1() {
  return getRuleContext<WatParser::Expr1Context>(0);
}

tree::TerminalNode* WatParser::ExprContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}


size_t WatParser::ExprContext::getRuleIndex() const {
  return WatParser::RuleExpr;
}

void WatParser::ExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr(this);
}

void WatParser::ExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr(this);
}


std::any WatParser::ExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitExpr(this);
  else
    return visitor->visitChildren(this);
}

WatParser::ExprContext* WatParser::expr() {
  ExprContext *_localctx = _tracker.createInstance<ExprContext>(_ctx, getState());
  enterRule(_localctx, 46, WatParser::RuleExpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(370);
    match(WatParser::LPAR);
    setState(371);
    expr1();
    setState(372);
    match(WatParser::RPAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr1Context ------------------------------------------------------------------

WatParser::Expr1Context::Expr1Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Plain_instrContext* WatParser::Expr1Context::plain_instr() {
  return getRuleContext<WatParser::Plain_instrContext>(0);
}

std::vector<WatParser::ExprContext *> WatParser::Expr1Context::expr() {
  return getRuleContexts<WatParser::ExprContext>();
}

WatParser::ExprContext* WatParser::Expr1Context::expr(size_t i) {
  return getRuleContext<WatParser::ExprContext>(i);
}

tree::TerminalNode* WatParser::Expr1Context::CALL_INDIRECT() {
  return getToken(WatParser::CALL_INDIRECT, 0);
}

WatParser::Call_expr_typeContext* WatParser::Expr1Context::call_expr_type() {
  return getRuleContext<WatParser::Call_expr_typeContext>(0);
}

tree::TerminalNode* WatParser::Expr1Context::BLOCK() {
  return getToken(WatParser::BLOCK, 0);
}

WatParser::BlockContext* WatParser::Expr1Context::block() {
  return getRuleContext<WatParser::BlockContext>(0);
}

WatParser::Bind_varContext* WatParser::Expr1Context::bind_var() {
  return getRuleContext<WatParser::Bind_varContext>(0);
}

tree::TerminalNode* WatParser::Expr1Context::LOOP() {
  return getToken(WatParser::LOOP, 0);
}

tree::TerminalNode* WatParser::Expr1Context::IF() {
  return getToken(WatParser::IF, 0);
}

WatParser::If_blockContext* WatParser::Expr1Context::if_block() {
  return getRuleContext<WatParser::If_blockContext>(0);
}


size_t WatParser::Expr1Context::getRuleIndex() const {
  return WatParser::RuleExpr1;
}

void WatParser::Expr1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr1(this);
}

void WatParser::Expr1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr1(this);
}


std::any WatParser::Expr1Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitExpr1(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Expr1Context* WatParser::expr1() {
  Expr1Context *_localctx = _tracker.createInstance<Expr1Context>(_ctx, getState());
  enterRule(_localctx, 48, WatParser::RuleExpr1);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(398);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case WatParser::CONST:
      case WatParser::NOP:
      case WatParser::UNREACHABLE:
      case WatParser::DROP:
      case WatParser::BR:
      case WatParser::BR_IF:
      case WatParser::BR_TABLE:
      case WatParser::RETURN:
      case WatParser::SELECT:
      case WatParser::CALL:
      case WatParser::LOCAL_GET:
      case WatParser::LOCAL_SET:
      case WatParser::LOCAL_TEE:
      case WatParser::GLOBAL_GET:
      case WatParser::GLOBAL_SET:
      case WatParser::LOAD:
      case WatParser::STORE:
      case WatParser::UNARY:
      case WatParser::BINARY:
      case WatParser::TEST:
      case WatParser::COMPARE:
      case WatParser::CONVERT:
      case WatParser::MEMORY_SIZE:
      case WatParser::MEMORY_GROW: {
        enterOuterAlt(_localctx, 1);
        setState(374);
        plain_instr();
        setState(378);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == WatParser::LPAR) {
          setState(375);
          expr();
          setState(380);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case WatParser::CALL_INDIRECT: {
        enterOuterAlt(_localctx, 2);
        setState(381);
        match(WatParser::CALL_INDIRECT);
        setState(382);
        call_expr_type();
        break;
      }

      case WatParser::BLOCK: {
        enterOuterAlt(_localctx, 3);
        setState(383);
        match(WatParser::BLOCK);
        setState(385);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WatParser::VAR) {
          setState(384);
          bind_var();
        }
        setState(387);
        block();
        break;
      }

      case WatParser::LOOP: {
        enterOuterAlt(_localctx, 4);
        setState(388);
        match(WatParser::LOOP);
        setState(390);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WatParser::VAR) {
          setState(389);
          bind_var();
        }
        setState(392);
        block();
        break;
      }

      case WatParser::IF: {
        enterOuterAlt(_localctx, 5);
        setState(393);
        match(WatParser::IF);
        setState(395);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WatParser::VAR) {
          setState(394);
          bind_var();
        }
        setState(397);
        if_block();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Call_expr_typeContext ------------------------------------------------------------------

WatParser::Call_expr_typeContext::Call_expr_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Call_expr_paramsContext* WatParser::Call_expr_typeContext::call_expr_params() {
  return getRuleContext<WatParser::Call_expr_paramsContext>(0);
}

WatParser::Type_useContext* WatParser::Call_expr_typeContext::type_use() {
  return getRuleContext<WatParser::Type_useContext>(0);
}


size_t WatParser::Call_expr_typeContext::getRuleIndex() const {
  return WatParser::RuleCall_expr_type;
}

void WatParser::Call_expr_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCall_expr_type(this);
}

void WatParser::Call_expr_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCall_expr_type(this);
}


std::any WatParser::Call_expr_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitCall_expr_type(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Call_expr_typeContext* WatParser::call_expr_type() {
  Call_expr_typeContext *_localctx = _tracker.createInstance<Call_expr_typeContext>(_ctx, getState());
  enterRule(_localctx, 50, WatParser::RuleCall_expr_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(401);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
    case 1: {
      setState(400);
      type_use();
      break;
    }

    default:
      break;
    }
    setState(403);
    call_expr_params();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Call_expr_paramsContext ------------------------------------------------------------------

WatParser::Call_expr_paramsContext::Call_expr_paramsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Call_expr_resultsContext* WatParser::Call_expr_paramsContext::call_expr_results() {
  return getRuleContext<WatParser::Call_expr_resultsContext>(0);
}

std::vector<tree::TerminalNode *> WatParser::Call_expr_paramsContext::LPAR() {
  return getTokens(WatParser::LPAR);
}

tree::TerminalNode* WatParser::Call_expr_paramsContext::LPAR(size_t i) {
  return getToken(WatParser::LPAR, i);
}

std::vector<tree::TerminalNode *> WatParser::Call_expr_paramsContext::PARAM() {
  return getTokens(WatParser::PARAM);
}

tree::TerminalNode* WatParser::Call_expr_paramsContext::PARAM(size_t i) {
  return getToken(WatParser::PARAM, i);
}

std::vector<tree::TerminalNode *> WatParser::Call_expr_paramsContext::RPAR() {
  return getTokens(WatParser::RPAR);
}

tree::TerminalNode* WatParser::Call_expr_paramsContext::RPAR(size_t i) {
  return getToken(WatParser::RPAR, i);
}

std::vector<WatParser::Value_typeContext *> WatParser::Call_expr_paramsContext::value_type() {
  return getRuleContexts<WatParser::Value_typeContext>();
}

WatParser::Value_typeContext* WatParser::Call_expr_paramsContext::value_type(size_t i) {
  return getRuleContext<WatParser::Value_typeContext>(i);
}


size_t WatParser::Call_expr_paramsContext::getRuleIndex() const {
  return WatParser::RuleCall_expr_params;
}

void WatParser::Call_expr_paramsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCall_expr_params(this);
}

void WatParser::Call_expr_paramsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCall_expr_params(this);
}


std::any WatParser::Call_expr_paramsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitCall_expr_params(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Call_expr_paramsContext* WatParser::call_expr_params() {
  Call_expr_paramsContext *_localctx = _tracker.createInstance<Call_expr_paramsContext>(_ctx, getState());
  enterRule(_localctx, 52, WatParser::RuleCall_expr_params);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(416);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(405);
        match(WatParser::LPAR);
        setState(406);
        match(WatParser::PARAM);
        setState(410);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == WatParser::VALUE_TYPE) {
          setState(407);
          value_type();
          setState(412);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(413);
        match(WatParser::RPAR); 
      }
      setState(418);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx);
    }
    setState(419);
    call_expr_results();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Call_expr_resultsContext ------------------------------------------------------------------

WatParser::Call_expr_resultsContext::Call_expr_resultsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> WatParser::Call_expr_resultsContext::LPAR() {
  return getTokens(WatParser::LPAR);
}

tree::TerminalNode* WatParser::Call_expr_resultsContext::LPAR(size_t i) {
  return getToken(WatParser::LPAR, i);
}

std::vector<tree::TerminalNode *> WatParser::Call_expr_resultsContext::RESULT() {
  return getTokens(WatParser::RESULT);
}

tree::TerminalNode* WatParser::Call_expr_resultsContext::RESULT(size_t i) {
  return getToken(WatParser::RESULT, i);
}

std::vector<tree::TerminalNode *> WatParser::Call_expr_resultsContext::RPAR() {
  return getTokens(WatParser::RPAR);
}

tree::TerminalNode* WatParser::Call_expr_resultsContext::RPAR(size_t i) {
  return getToken(WatParser::RPAR, i);
}

std::vector<WatParser::ExprContext *> WatParser::Call_expr_resultsContext::expr() {
  return getRuleContexts<WatParser::ExprContext>();
}

WatParser::ExprContext* WatParser::Call_expr_resultsContext::expr(size_t i) {
  return getRuleContext<WatParser::ExprContext>(i);
}

std::vector<WatParser::Value_typeContext *> WatParser::Call_expr_resultsContext::value_type() {
  return getRuleContexts<WatParser::Value_typeContext>();
}

WatParser::Value_typeContext* WatParser::Call_expr_resultsContext::value_type(size_t i) {
  return getRuleContext<WatParser::Value_typeContext>(i);
}


size_t WatParser::Call_expr_resultsContext::getRuleIndex() const {
  return WatParser::RuleCall_expr_results;
}

void WatParser::Call_expr_resultsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCall_expr_results(this);
}

void WatParser::Call_expr_resultsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCall_expr_results(this);
}


std::any WatParser::Call_expr_resultsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitCall_expr_results(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Call_expr_resultsContext* WatParser::call_expr_results() {
  Call_expr_resultsContext *_localctx = _tracker.createInstance<Call_expr_resultsContext>(_ctx, getState());
  enterRule(_localctx, 54, WatParser::RuleCall_expr_results);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(432);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(421);
        match(WatParser::LPAR);
        setState(422);
        match(WatParser::RESULT);
        setState(426);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == WatParser::VALUE_TYPE) {
          setState(423);
          value_type();
          setState(428);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(429);
        match(WatParser::RPAR); 
      }
      setState(434);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx);
    }
    setState(438);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == WatParser::LPAR) {
      setState(435);
      expr();
      setState(440);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_blockContext ------------------------------------------------------------------

WatParser::If_blockContext::If_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Block_typeContext* WatParser::If_blockContext::block_type() {
  return getRuleContext<WatParser::Block_typeContext>(0);
}

WatParser::If_blockContext* WatParser::If_blockContext::if_block() {
  return getRuleContext<WatParser::If_blockContext>(0);
}

std::vector<tree::TerminalNode *> WatParser::If_blockContext::LPAR() {
  return getTokens(WatParser::LPAR);
}

tree::TerminalNode* WatParser::If_blockContext::LPAR(size_t i) {
  return getToken(WatParser::LPAR, i);
}

tree::TerminalNode* WatParser::If_blockContext::THEN() {
  return getToken(WatParser::THEN, 0);
}

std::vector<WatParser::Instr_listContext *> WatParser::If_blockContext::instr_list() {
  return getRuleContexts<WatParser::Instr_listContext>();
}

WatParser::Instr_listContext* WatParser::If_blockContext::instr_list(size_t i) {
  return getRuleContext<WatParser::Instr_listContext>(i);
}

std::vector<tree::TerminalNode *> WatParser::If_blockContext::RPAR() {
  return getTokens(WatParser::RPAR);
}

tree::TerminalNode* WatParser::If_blockContext::RPAR(size_t i) {
  return getToken(WatParser::RPAR, i);
}

std::vector<WatParser::ExprContext *> WatParser::If_blockContext::expr() {
  return getRuleContexts<WatParser::ExprContext>();
}

WatParser::ExprContext* WatParser::If_blockContext::expr(size_t i) {
  return getRuleContext<WatParser::ExprContext>(i);
}

tree::TerminalNode* WatParser::If_blockContext::ELSE() {
  return getToken(WatParser::ELSE, 0);
}


size_t WatParser::If_blockContext::getRuleIndex() const {
  return WatParser::RuleIf_block;
}

void WatParser::If_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_block(this);
}

void WatParser::If_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_block(this);
}


std::any WatParser::If_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitIf_block(this);
  else
    return visitor->visitChildren(this);
}

WatParser::If_blockContext* WatParser::if_block() {
  If_blockContext *_localctx = _tracker.createInstance<If_blockContext>(_ctx, getState());
  enterRule(_localctx, 56, WatParser::RuleIf_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(461);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(441);
      block_type();
      setState(442);
      if_block();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(447);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(444);
          expr(); 
        }
        setState(449);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx);
      }
      setState(450);
      match(WatParser::LPAR);
      setState(451);
      match(WatParser::THEN);
      setState(452);
      instr_list();
      setState(453);
      match(WatParser::RPAR);
      setState(459);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WatParser::LPAR) {
        setState(454);
        match(WatParser::LPAR);
        setState(455);
        match(WatParser::ELSE);
        setState(456);
        instr_list();
        setState(457);
        match(WatParser::RPAR);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Instr_listContext ------------------------------------------------------------------

WatParser::Instr_listContext::Instr_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<WatParser::InstrContext *> WatParser::Instr_listContext::instr() {
  return getRuleContexts<WatParser::InstrContext>();
}

WatParser::InstrContext* WatParser::Instr_listContext::instr(size_t i) {
  return getRuleContext<WatParser::InstrContext>(i);
}

WatParser::Call_instrContext* WatParser::Instr_listContext::call_instr() {
  return getRuleContext<WatParser::Call_instrContext>(0);
}


size_t WatParser::Instr_listContext::getRuleIndex() const {
  return WatParser::RuleInstr_list;
}

void WatParser::Instr_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInstr_list(this);
}

void WatParser::Instr_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInstr_list(this);
}


std::any WatParser::Instr_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitInstr_list(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Instr_listContext* WatParser::instr_list() {
  Instr_listContext *_localctx = _tracker.createInstance<Instr_listContext>(_ctx, getState());
  enterRule(_localctx, 58, WatParser::RuleInstr_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(466);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(463);
        instr(); 
      }
      setState(468);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx);
    }
    setState(470);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == WatParser::CALL_INDIRECT) {
      setState(469);
      call_instr();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_exprContext ------------------------------------------------------------------

WatParser::Const_exprContext::Const_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Instr_listContext* WatParser::Const_exprContext::instr_list() {
  return getRuleContext<WatParser::Instr_listContext>(0);
}


size_t WatParser::Const_exprContext::getRuleIndex() const {
  return WatParser::RuleConst_expr;
}

void WatParser::Const_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_expr(this);
}

void WatParser::Const_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_expr(this);
}


std::any WatParser::Const_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitConst_expr(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Const_exprContext* WatParser::const_expr() {
  Const_exprContext *_localctx = _tracker.createInstance<Const_exprContext>(_ctx, getState());
  enterRule(_localctx, 60, WatParser::RuleConst_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(472);
    instr_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_Context ------------------------------------------------------------------

WatParser::Func_Context::Func_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Func_Context::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::Func_Context::FUNC() {
  return getToken(WatParser::FUNC, 0);
}

WatParser::Func_fieldsContext* WatParser::Func_Context::func_fields() {
  return getRuleContext<WatParser::Func_fieldsContext>(0);
}

tree::TerminalNode* WatParser::Func_Context::RPAR() {
  return getToken(WatParser::RPAR, 0);
}

WatParser::Bind_varContext* WatParser::Func_Context::bind_var() {
  return getRuleContext<WatParser::Bind_varContext>(0);
}


size_t WatParser::Func_Context::getRuleIndex() const {
  return WatParser::RuleFunc_;
}

void WatParser::Func_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_(this);
}

void WatParser::Func_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_(this);
}


std::any WatParser::Func_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitFunc_(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Func_Context* WatParser::func_() {
  Func_Context *_localctx = _tracker.createInstance<Func_Context>(_ctx, getState());
  enterRule(_localctx, 62, WatParser::RuleFunc_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(474);
    match(WatParser::LPAR);
    setState(475);
    match(WatParser::FUNC);
    setState(477);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == WatParser::VAR) {
      setState(476);
      bind_var();
    }
    setState(479);
    func_fields();
    setState(480);
    match(WatParser::RPAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_fieldsContext ------------------------------------------------------------------

WatParser::Func_fieldsContext::Func_fieldsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Func_fields_bodyContext* WatParser::Func_fieldsContext::func_fields_body() {
  return getRuleContext<WatParser::Func_fields_bodyContext>(0);
}

WatParser::Type_useContext* WatParser::Func_fieldsContext::type_use() {
  return getRuleContext<WatParser::Type_useContext>(0);
}

WatParser::Inline_importContext* WatParser::Func_fieldsContext::inline_import() {
  return getRuleContext<WatParser::Inline_importContext>(0);
}

WatParser::Func_fields_importContext* WatParser::Func_fieldsContext::func_fields_import() {
  return getRuleContext<WatParser::Func_fields_importContext>(0);
}

WatParser::Inline_exportContext* WatParser::Func_fieldsContext::inline_export() {
  return getRuleContext<WatParser::Inline_exportContext>(0);
}

WatParser::Func_fieldsContext* WatParser::Func_fieldsContext::func_fields() {
  return getRuleContext<WatParser::Func_fieldsContext>(0);
}


size_t WatParser::Func_fieldsContext::getRuleIndex() const {
  return WatParser::RuleFunc_fields;
}

void WatParser::Func_fieldsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_fields(this);
}

void WatParser::Func_fieldsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_fields(this);
}


std::any WatParser::Func_fieldsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitFunc_fields(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Func_fieldsContext* WatParser::func_fields() {
  Func_fieldsContext *_localctx = _tracker.createInstance<Func_fieldsContext>(_ctx, getState());
  enterRule(_localctx, 64, WatParser::RuleFunc_fields);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(495);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(483);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
      case 1: {
        setState(482);
        type_use();
        break;
      }

      default:
        break;
      }
      setState(485);
      func_fields_body();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(486);
      inline_import();
      setState(488);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx)) {
      case 1: {
        setState(487);
        type_use();
        break;
      }

      default:
        break;
      }
      setState(490);
      func_fields_import();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(492);
      inline_export();
      setState(493);
      func_fields();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_fields_importContext ------------------------------------------------------------------

WatParser::Func_fields_importContext::Func_fields_importContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Func_fields_import_resultContext* WatParser::Func_fields_importContext::func_fields_import_result() {
  return getRuleContext<WatParser::Func_fields_import_resultContext>(0);
}

tree::TerminalNode* WatParser::Func_fields_importContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::Func_fields_importContext::PARAM() {
  return getToken(WatParser::PARAM, 0);
}

tree::TerminalNode* WatParser::Func_fields_importContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}

WatParser::Bind_varContext* WatParser::Func_fields_importContext::bind_var() {
  return getRuleContext<WatParser::Bind_varContext>(0);
}

std::vector<WatParser::Value_typeContext *> WatParser::Func_fields_importContext::value_type() {
  return getRuleContexts<WatParser::Value_typeContext>();
}

WatParser::Value_typeContext* WatParser::Func_fields_importContext::value_type(size_t i) {
  return getRuleContext<WatParser::Value_typeContext>(i);
}


size_t WatParser::Func_fields_importContext::getRuleIndex() const {
  return WatParser::RuleFunc_fields_import;
}

void WatParser::Func_fields_importContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_fields_import(this);
}

void WatParser::Func_fields_importContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_fields_import(this);
}


std::any WatParser::Func_fields_importContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitFunc_fields_import(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Func_fields_importContext* WatParser::func_fields_import() {
  Func_fields_importContext *_localctx = _tracker.createInstance<Func_fields_importContext>(_ctx, getState());
  enterRule(_localctx, 66, WatParser::RuleFunc_fields_import);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(512);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
    case 1: {
      setState(497);
      match(WatParser::LPAR);
      setState(498);
      match(WatParser::PARAM);
      setState(502);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WatParser::VALUE_TYPE) {
        setState(499);
        value_type();
        setState(504);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(505);
      match(WatParser::RPAR);
      break;
    }

    case 2: {
      setState(506);
      match(WatParser::LPAR);
      setState(507);
      match(WatParser::PARAM);
      setState(508);
      bind_var();
      setState(509);
      value_type();
      setState(510);
      match(WatParser::RPAR);
      break;
    }

    default:
      break;
    }
    setState(514);
    func_fields_import_result();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_fields_import_resultContext ------------------------------------------------------------------

WatParser::Func_fields_import_resultContext::Func_fields_import_resultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> WatParser::Func_fields_import_resultContext::LPAR() {
  return getTokens(WatParser::LPAR);
}

tree::TerminalNode* WatParser::Func_fields_import_resultContext::LPAR(size_t i) {
  return getToken(WatParser::LPAR, i);
}

std::vector<tree::TerminalNode *> WatParser::Func_fields_import_resultContext::RESULT() {
  return getTokens(WatParser::RESULT);
}

tree::TerminalNode* WatParser::Func_fields_import_resultContext::RESULT(size_t i) {
  return getToken(WatParser::RESULT, i);
}

std::vector<tree::TerminalNode *> WatParser::Func_fields_import_resultContext::RPAR() {
  return getTokens(WatParser::RPAR);
}

tree::TerminalNode* WatParser::Func_fields_import_resultContext::RPAR(size_t i) {
  return getToken(WatParser::RPAR, i);
}

std::vector<WatParser::Value_typeContext *> WatParser::Func_fields_import_resultContext::value_type() {
  return getRuleContexts<WatParser::Value_typeContext>();
}

WatParser::Value_typeContext* WatParser::Func_fields_import_resultContext::value_type(size_t i) {
  return getRuleContext<WatParser::Value_typeContext>(i);
}


size_t WatParser::Func_fields_import_resultContext::getRuleIndex() const {
  return WatParser::RuleFunc_fields_import_result;
}

void WatParser::Func_fields_import_resultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_fields_import_result(this);
}

void WatParser::Func_fields_import_resultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_fields_import_result(this);
}


std::any WatParser::Func_fields_import_resultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitFunc_fields_import_result(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Func_fields_import_resultContext* WatParser::func_fields_import_result() {
  Func_fields_import_resultContext *_localctx = _tracker.createInstance<Func_fields_import_resultContext>(_ctx, getState());
  enterRule(_localctx, 68, WatParser::RuleFunc_fields_import_result);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(527);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == WatParser::LPAR) {
      setState(516);
      match(WatParser::LPAR);
      setState(517);
      match(WatParser::RESULT);
      setState(521);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WatParser::VALUE_TYPE) {
        setState(518);
        value_type();
        setState(523);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(524);
      match(WatParser::RPAR);
      setState(529);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_fields_bodyContext ------------------------------------------------------------------

WatParser::Func_fields_bodyContext::Func_fields_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Func_result_bodyContext* WatParser::Func_fields_bodyContext::func_result_body() {
  return getRuleContext<WatParser::Func_result_bodyContext>(0);
}

std::vector<tree::TerminalNode *> WatParser::Func_fields_bodyContext::LPAR() {
  return getTokens(WatParser::LPAR);
}

tree::TerminalNode* WatParser::Func_fields_bodyContext::LPAR(size_t i) {
  return getToken(WatParser::LPAR, i);
}

std::vector<tree::TerminalNode *> WatParser::Func_fields_bodyContext::PARAM() {
  return getTokens(WatParser::PARAM);
}

tree::TerminalNode* WatParser::Func_fields_bodyContext::PARAM(size_t i) {
  return getToken(WatParser::PARAM, i);
}

std::vector<tree::TerminalNode *> WatParser::Func_fields_bodyContext::RPAR() {
  return getTokens(WatParser::RPAR);
}

tree::TerminalNode* WatParser::Func_fields_bodyContext::RPAR(size_t i) {
  return getToken(WatParser::RPAR, i);
}

std::vector<WatParser::Bind_varContext *> WatParser::Func_fields_bodyContext::bind_var() {
  return getRuleContexts<WatParser::Bind_varContext>();
}

WatParser::Bind_varContext* WatParser::Func_fields_bodyContext::bind_var(size_t i) {
  return getRuleContext<WatParser::Bind_varContext>(i);
}

std::vector<WatParser::Value_typeContext *> WatParser::Func_fields_bodyContext::value_type() {
  return getRuleContexts<WatParser::Value_typeContext>();
}

WatParser::Value_typeContext* WatParser::Func_fields_bodyContext::value_type(size_t i) {
  return getRuleContext<WatParser::Value_typeContext>(i);
}


size_t WatParser::Func_fields_bodyContext::getRuleIndex() const {
  return WatParser::RuleFunc_fields_body;
}

void WatParser::Func_fields_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_fields_body(this);
}

void WatParser::Func_fields_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_fields_body(this);
}


std::any WatParser::Func_fields_bodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitFunc_fields_body(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Func_fields_bodyContext* WatParser::func_fields_body() {
  Func_fields_bodyContext *_localctx = _tracker.createInstance<Func_fields_bodyContext>(_ctx, getState());
  enterRule(_localctx, 70, WatParser::RuleFunc_fields_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(547);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(545);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
        case 1: {
          setState(530);
          match(WatParser::LPAR);
          setState(531);
          match(WatParser::PARAM);
          setState(535);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == WatParser::VALUE_TYPE) {
            setState(532);
            value_type();
            setState(537);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(538);
          match(WatParser::RPAR);
          break;
        }

        case 2: {
          setState(539);
          match(WatParser::LPAR);
          setState(540);
          match(WatParser::PARAM);
          setState(541);
          bind_var();
          setState(542);
          value_type();
          setState(543);
          match(WatParser::RPAR);
          break;
        }

        default:
          break;
        } 
      }
      setState(549);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx);
    }
    setState(550);
    func_result_body();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_result_bodyContext ------------------------------------------------------------------

WatParser::Func_result_bodyContext::Func_result_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Func_bodyContext* WatParser::Func_result_bodyContext::func_body() {
  return getRuleContext<WatParser::Func_bodyContext>(0);
}

std::vector<tree::TerminalNode *> WatParser::Func_result_bodyContext::LPAR() {
  return getTokens(WatParser::LPAR);
}

tree::TerminalNode* WatParser::Func_result_bodyContext::LPAR(size_t i) {
  return getToken(WatParser::LPAR, i);
}

std::vector<tree::TerminalNode *> WatParser::Func_result_bodyContext::RESULT() {
  return getTokens(WatParser::RESULT);
}

tree::TerminalNode* WatParser::Func_result_bodyContext::RESULT(size_t i) {
  return getToken(WatParser::RESULT, i);
}

std::vector<tree::TerminalNode *> WatParser::Func_result_bodyContext::RPAR() {
  return getTokens(WatParser::RPAR);
}

tree::TerminalNode* WatParser::Func_result_bodyContext::RPAR(size_t i) {
  return getToken(WatParser::RPAR, i);
}

std::vector<WatParser::Value_typeContext *> WatParser::Func_result_bodyContext::value_type() {
  return getRuleContexts<WatParser::Value_typeContext>();
}

WatParser::Value_typeContext* WatParser::Func_result_bodyContext::value_type(size_t i) {
  return getRuleContext<WatParser::Value_typeContext>(i);
}


size_t WatParser::Func_result_bodyContext::getRuleIndex() const {
  return WatParser::RuleFunc_result_body;
}

void WatParser::Func_result_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_result_body(this);
}

void WatParser::Func_result_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_result_body(this);
}


std::any WatParser::Func_result_bodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitFunc_result_body(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Func_result_bodyContext* WatParser::func_result_body() {
  Func_result_bodyContext *_localctx = _tracker.createInstance<Func_result_bodyContext>(_ctx, getState());
  enterRule(_localctx, 72, WatParser::RuleFunc_result_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(563);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(552);
        match(WatParser::LPAR);
        setState(553);
        match(WatParser::RESULT);
        setState(557);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == WatParser::VALUE_TYPE) {
          setState(554);
          value_type();
          setState(559);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(560);
        match(WatParser::RPAR); 
      }
      setState(565);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx);
    }
    setState(566);
    func_body();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_bodyContext ------------------------------------------------------------------

WatParser::Func_bodyContext::Func_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Instr_listContext* WatParser::Func_bodyContext::instr_list() {
  return getRuleContext<WatParser::Instr_listContext>(0);
}

std::vector<tree::TerminalNode *> WatParser::Func_bodyContext::LPAR() {
  return getTokens(WatParser::LPAR);
}

tree::TerminalNode* WatParser::Func_bodyContext::LPAR(size_t i) {
  return getToken(WatParser::LPAR, i);
}

std::vector<tree::TerminalNode *> WatParser::Func_bodyContext::LOCAL() {
  return getTokens(WatParser::LOCAL);
}

tree::TerminalNode* WatParser::Func_bodyContext::LOCAL(size_t i) {
  return getToken(WatParser::LOCAL, i);
}

std::vector<tree::TerminalNode *> WatParser::Func_bodyContext::RPAR() {
  return getTokens(WatParser::RPAR);
}

tree::TerminalNode* WatParser::Func_bodyContext::RPAR(size_t i) {
  return getToken(WatParser::RPAR, i);
}

std::vector<WatParser::Bind_varContext *> WatParser::Func_bodyContext::bind_var() {
  return getRuleContexts<WatParser::Bind_varContext>();
}

WatParser::Bind_varContext* WatParser::Func_bodyContext::bind_var(size_t i) {
  return getRuleContext<WatParser::Bind_varContext>(i);
}

std::vector<WatParser::Value_typeContext *> WatParser::Func_bodyContext::value_type() {
  return getRuleContexts<WatParser::Value_typeContext>();
}

WatParser::Value_typeContext* WatParser::Func_bodyContext::value_type(size_t i) {
  return getRuleContext<WatParser::Value_typeContext>(i);
}


size_t WatParser::Func_bodyContext::getRuleIndex() const {
  return WatParser::RuleFunc_body;
}

void WatParser::Func_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_body(this);
}

void WatParser::Func_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_body(this);
}


std::any WatParser::Func_bodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitFunc_body(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Func_bodyContext* WatParser::func_body() {
  Func_bodyContext *_localctx = _tracker.createInstance<Func_bodyContext>(_ctx, getState());
  enterRule(_localctx, 74, WatParser::RuleFunc_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(585);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(583);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
        case 1: {
          setState(568);
          match(WatParser::LPAR);
          setState(569);
          match(WatParser::LOCAL);
          setState(573);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == WatParser::VALUE_TYPE) {
            setState(570);
            value_type();
            setState(575);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(576);
          match(WatParser::RPAR);
          break;
        }

        case 2: {
          setState(577);
          match(WatParser::LPAR);
          setState(578);
          match(WatParser::LOCAL);
          setState(579);
          bind_var();
          setState(580);
          value_type();
          setState(581);
          match(WatParser::RPAR);
          break;
        }

        default:
          break;
        } 
      }
      setState(587);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx);
    }
    setState(588);
    instr_list();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OffsetContext ------------------------------------------------------------------

WatParser::OffsetContext::OffsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::OffsetContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::OffsetContext::OFFSET() {
  return getToken(WatParser::OFFSET, 0);
}

WatParser::Const_exprContext* WatParser::OffsetContext::const_expr() {
  return getRuleContext<WatParser::Const_exprContext>(0);
}

tree::TerminalNode* WatParser::OffsetContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}

WatParser::ExprContext* WatParser::OffsetContext::expr() {
  return getRuleContext<WatParser::ExprContext>(0);
}


size_t WatParser::OffsetContext::getRuleIndex() const {
  return WatParser::RuleOffset;
}

void WatParser::OffsetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOffset(this);
}

void WatParser::OffsetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOffset(this);
}


std::any WatParser::OffsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitOffset(this);
  else
    return visitor->visitChildren(this);
}

WatParser::OffsetContext* WatParser::offset() {
  OffsetContext *_localctx = _tracker.createInstance<OffsetContext>(_ctx, getState());
  enterRule(_localctx, 76, WatParser::RuleOffset);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(596);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(590);
      match(WatParser::LPAR);
      setState(591);
      match(WatParser::OFFSET);
      setState(592);
      const_expr();
      setState(593);
      match(WatParser::RPAR);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(595);
      expr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElemContext ------------------------------------------------------------------

WatParser::ElemContext::ElemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::ElemContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::ElemContext::ELEM() {
  return getToken(WatParser::ELEM, 0);
}

WatParser::OffsetContext* WatParser::ElemContext::offset() {
  return getRuleContext<WatParser::OffsetContext>(0);
}

tree::TerminalNode* WatParser::ElemContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}

std::vector<WatParser::Var_Context *> WatParser::ElemContext::var_() {
  return getRuleContexts<WatParser::Var_Context>();
}

WatParser::Var_Context* WatParser::ElemContext::var_(size_t i) {
  return getRuleContext<WatParser::Var_Context>(i);
}


size_t WatParser::ElemContext::getRuleIndex() const {
  return WatParser::RuleElem;
}

void WatParser::ElemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElem(this);
}

void WatParser::ElemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElem(this);
}


std::any WatParser::ElemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitElem(this);
  else
    return visitor->visitChildren(this);
}

WatParser::ElemContext* WatParser::elem() {
  ElemContext *_localctx = _tracker.createInstance<ElemContext>(_ctx, getState());
  enterRule(_localctx, 78, WatParser::RuleElem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(598);
    match(WatParser::LPAR);
    setState(599);
    match(WatParser::ELEM);
    setState(601);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == WatParser::NAT || _la == WatParser::VAR) {
      setState(600);
      var_();
    }
    setState(603);
    offset();
    setState(607);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == WatParser::NAT || _la == WatParser::VAR) {
      setState(604);
      var_();
      setState(609);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(610);
    match(WatParser::RPAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableContext ------------------------------------------------------------------

WatParser::TableContext::TableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::TableContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::TableContext::TABLE() {
  return getToken(WatParser::TABLE, 0);
}

WatParser::Table_fieldsContext* WatParser::TableContext::table_fields() {
  return getRuleContext<WatParser::Table_fieldsContext>(0);
}

tree::TerminalNode* WatParser::TableContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}

WatParser::Bind_varContext* WatParser::TableContext::bind_var() {
  return getRuleContext<WatParser::Bind_varContext>(0);
}


size_t WatParser::TableContext::getRuleIndex() const {
  return WatParser::RuleTable;
}

void WatParser::TableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable(this);
}

void WatParser::TableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable(this);
}


std::any WatParser::TableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitTable(this);
  else
    return visitor->visitChildren(this);
}

WatParser::TableContext* WatParser::table() {
  TableContext *_localctx = _tracker.createInstance<TableContext>(_ctx, getState());
  enterRule(_localctx, 80, WatParser::RuleTable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(612);
    match(WatParser::LPAR);
    setState(613);
    match(WatParser::TABLE);
    setState(615);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == WatParser::VAR) {
      setState(614);
      bind_var();
    }
    setState(617);
    table_fields();
    setState(618);
    match(WatParser::RPAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_fieldsContext ------------------------------------------------------------------

WatParser::Table_fieldsContext::Table_fieldsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Table_typeContext* WatParser::Table_fieldsContext::table_type() {
  return getRuleContext<WatParser::Table_typeContext>(0);
}

WatParser::Inline_importContext* WatParser::Table_fieldsContext::inline_import() {
  return getRuleContext<WatParser::Inline_importContext>(0);
}

WatParser::Inline_exportContext* WatParser::Table_fieldsContext::inline_export() {
  return getRuleContext<WatParser::Inline_exportContext>(0);
}

WatParser::Table_fieldsContext* WatParser::Table_fieldsContext::table_fields() {
  return getRuleContext<WatParser::Table_fieldsContext>(0);
}

WatParser::Elem_typeContext* WatParser::Table_fieldsContext::elem_type() {
  return getRuleContext<WatParser::Elem_typeContext>(0);
}

tree::TerminalNode* WatParser::Table_fieldsContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::Table_fieldsContext::ELEM() {
  return getToken(WatParser::ELEM, 0);
}

tree::TerminalNode* WatParser::Table_fieldsContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}

std::vector<WatParser::Var_Context *> WatParser::Table_fieldsContext::var_() {
  return getRuleContexts<WatParser::Var_Context>();
}

WatParser::Var_Context* WatParser::Table_fieldsContext::var_(size_t i) {
  return getRuleContext<WatParser::Var_Context>(i);
}


size_t WatParser::Table_fieldsContext::getRuleIndex() const {
  return WatParser::RuleTable_fields;
}

void WatParser::Table_fieldsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_fields(this);
}

void WatParser::Table_fieldsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_fields(this);
}


std::any WatParser::Table_fieldsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitTable_fields(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Table_fieldsContext* WatParser::table_fields() {
  Table_fieldsContext *_localctx = _tracker.createInstance<Table_fieldsContext>(_ctx, getState());
  enterRule(_localctx, 82, WatParser::RuleTable_fields);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(638);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(620);
      table_type();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(621);
      inline_import();
      setState(622);
      table_type();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(624);
      inline_export();
      setState(625);
      table_fields();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(627);
      elem_type();
      setState(628);
      match(WatParser::LPAR);
      setState(629);
      match(WatParser::ELEM);
      setState(633);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WatParser::NAT || _la == WatParser::VAR) {
        setState(630);
        var_();
        setState(635);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(636);
      match(WatParser::RPAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataContext ------------------------------------------------------------------

WatParser::DataContext::DataContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::DataContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::DataContext::DATA() {
  return getToken(WatParser::DATA, 0);
}

WatParser::OffsetContext* WatParser::DataContext::offset() {
  return getRuleContext<WatParser::OffsetContext>(0);
}

tree::TerminalNode* WatParser::DataContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}

WatParser::Var_Context* WatParser::DataContext::var_() {
  return getRuleContext<WatParser::Var_Context>(0);
}

std::vector<tree::TerminalNode *> WatParser::DataContext::STRING_() {
  return getTokens(WatParser::STRING_);
}

tree::TerminalNode* WatParser::DataContext::STRING_(size_t i) {
  return getToken(WatParser::STRING_, i);
}


size_t WatParser::DataContext::getRuleIndex() const {
  return WatParser::RuleData;
}

void WatParser::DataContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterData(this);
}

void WatParser::DataContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitData(this);
}


std::any WatParser::DataContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitData(this);
  else
    return visitor->visitChildren(this);
}

WatParser::DataContext* WatParser::data() {
  DataContext *_localctx = _tracker.createInstance<DataContext>(_ctx, getState());
  enterRule(_localctx, 84, WatParser::RuleData);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(640);
    match(WatParser::LPAR);
    setState(641);
    match(WatParser::DATA);
    setState(643);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == WatParser::NAT || _la == WatParser::VAR) {
      setState(642);
      var_();
    }
    setState(645);
    offset();
    setState(649);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == WatParser::STRING_) {
      setState(646);
      match(WatParser::STRING_);
      setState(651);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(652);
    match(WatParser::RPAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MemoryContext ------------------------------------------------------------------

WatParser::MemoryContext::MemoryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::MemoryContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::MemoryContext::MEMORY() {
  return getToken(WatParser::MEMORY, 0);
}

WatParser::Memory_fieldsContext* WatParser::MemoryContext::memory_fields() {
  return getRuleContext<WatParser::Memory_fieldsContext>(0);
}

tree::TerminalNode* WatParser::MemoryContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}

WatParser::Bind_varContext* WatParser::MemoryContext::bind_var() {
  return getRuleContext<WatParser::Bind_varContext>(0);
}


size_t WatParser::MemoryContext::getRuleIndex() const {
  return WatParser::RuleMemory;
}

void WatParser::MemoryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemory(this);
}

void WatParser::MemoryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemory(this);
}


std::any WatParser::MemoryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitMemory(this);
  else
    return visitor->visitChildren(this);
}

WatParser::MemoryContext* WatParser::memory() {
  MemoryContext *_localctx = _tracker.createInstance<MemoryContext>(_ctx, getState());
  enterRule(_localctx, 86, WatParser::RuleMemory);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(654);
    match(WatParser::LPAR);
    setState(655);
    match(WatParser::MEMORY);
    setState(657);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == WatParser::VAR) {
      setState(656);
      bind_var();
    }
    setState(659);
    memory_fields();
    setState(660);
    match(WatParser::RPAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Memory_fieldsContext ------------------------------------------------------------------

WatParser::Memory_fieldsContext::Memory_fieldsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Memory_typeContext* WatParser::Memory_fieldsContext::memory_type() {
  return getRuleContext<WatParser::Memory_typeContext>(0);
}

WatParser::Inline_importContext* WatParser::Memory_fieldsContext::inline_import() {
  return getRuleContext<WatParser::Inline_importContext>(0);
}

WatParser::Inline_exportContext* WatParser::Memory_fieldsContext::inline_export() {
  return getRuleContext<WatParser::Inline_exportContext>(0);
}

WatParser::Memory_fieldsContext* WatParser::Memory_fieldsContext::memory_fields() {
  return getRuleContext<WatParser::Memory_fieldsContext>(0);
}

tree::TerminalNode* WatParser::Memory_fieldsContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::Memory_fieldsContext::DATA() {
  return getToken(WatParser::DATA, 0);
}

tree::TerminalNode* WatParser::Memory_fieldsContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}

std::vector<tree::TerminalNode *> WatParser::Memory_fieldsContext::STRING_() {
  return getTokens(WatParser::STRING_);
}

tree::TerminalNode* WatParser::Memory_fieldsContext::STRING_(size_t i) {
  return getToken(WatParser::STRING_, i);
}


size_t WatParser::Memory_fieldsContext::getRuleIndex() const {
  return WatParser::RuleMemory_fields;
}

void WatParser::Memory_fieldsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemory_fields(this);
}

void WatParser::Memory_fieldsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemory_fields(this);
}


std::any WatParser::Memory_fieldsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitMemory_fields(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Memory_fieldsContext* WatParser::memory_fields() {
  Memory_fieldsContext *_localctx = _tracker.createInstance<Memory_fieldsContext>(_ctx, getState());
  enterRule(_localctx, 88, WatParser::RuleMemory_fields);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(678);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(662);
      memory_type();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(663);
      inline_import();
      setState(664);
      memory_type();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(666);
      inline_export();
      setState(667);
      memory_fields();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(669);
      match(WatParser::LPAR);
      setState(670);
      match(WatParser::DATA);
      setState(674);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WatParser::STRING_) {
        setState(671);
        match(WatParser::STRING_);
        setState(676);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(677);
      match(WatParser::RPAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SglobalContext ------------------------------------------------------------------

WatParser::SglobalContext::SglobalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::SglobalContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::SglobalContext::GLOBAL() {
  return getToken(WatParser::GLOBAL, 0);
}

WatParser::Global_fieldsContext* WatParser::SglobalContext::global_fields() {
  return getRuleContext<WatParser::Global_fieldsContext>(0);
}

tree::TerminalNode* WatParser::SglobalContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}

WatParser::Bind_varContext* WatParser::SglobalContext::bind_var() {
  return getRuleContext<WatParser::Bind_varContext>(0);
}


size_t WatParser::SglobalContext::getRuleIndex() const {
  return WatParser::RuleSglobal;
}

void WatParser::SglobalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSglobal(this);
}

void WatParser::SglobalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSglobal(this);
}


std::any WatParser::SglobalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitSglobal(this);
  else
    return visitor->visitChildren(this);
}

WatParser::SglobalContext* WatParser::sglobal() {
  SglobalContext *_localctx = _tracker.createInstance<SglobalContext>(_ctx, getState());
  enterRule(_localctx, 90, WatParser::RuleSglobal);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(680);
    match(WatParser::LPAR);
    setState(681);
    match(WatParser::GLOBAL);
    setState(683);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == WatParser::VAR) {
      setState(682);
      bind_var();
    }
    setState(685);
    global_fields();
    setState(686);
    match(WatParser::RPAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Global_fieldsContext ------------------------------------------------------------------

WatParser::Global_fieldsContext::Global_fieldsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Global_typeContext* WatParser::Global_fieldsContext::global_type() {
  return getRuleContext<WatParser::Global_typeContext>(0);
}

WatParser::Const_exprContext* WatParser::Global_fieldsContext::const_expr() {
  return getRuleContext<WatParser::Const_exprContext>(0);
}

WatParser::Inline_importContext* WatParser::Global_fieldsContext::inline_import() {
  return getRuleContext<WatParser::Inline_importContext>(0);
}

WatParser::Inline_exportContext* WatParser::Global_fieldsContext::inline_export() {
  return getRuleContext<WatParser::Inline_exportContext>(0);
}

WatParser::Global_fieldsContext* WatParser::Global_fieldsContext::global_fields() {
  return getRuleContext<WatParser::Global_fieldsContext>(0);
}


size_t WatParser::Global_fieldsContext::getRuleIndex() const {
  return WatParser::RuleGlobal_fields;
}

void WatParser::Global_fieldsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGlobal_fields(this);
}

void WatParser::Global_fieldsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGlobal_fields(this);
}


std::any WatParser::Global_fieldsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitGlobal_fields(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Global_fieldsContext* WatParser::global_fields() {
  Global_fieldsContext *_localctx = _tracker.createInstance<Global_fieldsContext>(_ctx, getState());
  enterRule(_localctx, 92, WatParser::RuleGlobal_fields);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(697);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(688);
      global_type();
      setState(689);
      const_expr();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(691);
      inline_import();
      setState(692);
      global_type();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(694);
      inline_export();
      setState(695);
      global_fields();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_descContext ------------------------------------------------------------------

WatParser::Import_descContext::Import_descContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Import_descContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::Import_descContext::FUNC() {
  return getToken(WatParser::FUNC, 0);
}

WatParser::Type_useContext* WatParser::Import_descContext::type_use() {
  return getRuleContext<WatParser::Type_useContext>(0);
}

tree::TerminalNode* WatParser::Import_descContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}

WatParser::Bind_varContext* WatParser::Import_descContext::bind_var() {
  return getRuleContext<WatParser::Bind_varContext>(0);
}

WatParser::Func_typeContext* WatParser::Import_descContext::func_type() {
  return getRuleContext<WatParser::Func_typeContext>(0);
}

tree::TerminalNode* WatParser::Import_descContext::TABLE() {
  return getToken(WatParser::TABLE, 0);
}

WatParser::Table_typeContext* WatParser::Import_descContext::table_type() {
  return getRuleContext<WatParser::Table_typeContext>(0);
}

tree::TerminalNode* WatParser::Import_descContext::MEMORY() {
  return getToken(WatParser::MEMORY, 0);
}

WatParser::Memory_typeContext* WatParser::Import_descContext::memory_type() {
  return getRuleContext<WatParser::Memory_typeContext>(0);
}

tree::TerminalNode* WatParser::Import_descContext::GLOBAL() {
  return getToken(WatParser::GLOBAL, 0);
}

WatParser::Global_typeContext* WatParser::Import_descContext::global_type() {
  return getRuleContext<WatParser::Global_typeContext>(0);
}


size_t WatParser::Import_descContext::getRuleIndex() const {
  return WatParser::RuleImport_desc;
}

void WatParser::Import_descContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_desc(this);
}

void WatParser::Import_descContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_desc(this);
}


std::any WatParser::Import_descContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitImport_desc(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Import_descContext* WatParser::import_desc() {
  Import_descContext *_localctx = _tracker.createInstance<Import_descContext>(_ctx, getState());
  enterRule(_localctx, 94, WatParser::RuleImport_desc);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(739);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(699);
      match(WatParser::LPAR);
      setState(700);
      match(WatParser::FUNC);
      setState(702);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WatParser::VAR) {
        setState(701);
        bind_var();
      }
      setState(704);
      type_use();
      setState(705);
      match(WatParser::RPAR);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(707);
      match(WatParser::LPAR);
      setState(708);
      match(WatParser::FUNC);
      setState(710);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WatParser::VAR) {
        setState(709);
        bind_var();
      }
      setState(712);
      func_type();
      setState(713);
      match(WatParser::RPAR);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(715);
      match(WatParser::LPAR);
      setState(716);
      match(WatParser::TABLE);
      setState(718);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WatParser::VAR) {
        setState(717);
        bind_var();
      }
      setState(720);
      table_type();
      setState(721);
      match(WatParser::RPAR);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(723);
      match(WatParser::LPAR);
      setState(724);
      match(WatParser::MEMORY);
      setState(726);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WatParser::VAR) {
        setState(725);
        bind_var();
      }
      setState(728);
      memory_type();
      setState(729);
      match(WatParser::RPAR);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(731);
      match(WatParser::LPAR);
      setState(732);
      match(WatParser::GLOBAL);
      setState(734);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WatParser::VAR) {
        setState(733);
        bind_var();
      }
      setState(736);
      global_type();
      setState(737);
      match(WatParser::RPAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimportContext ------------------------------------------------------------------

WatParser::SimportContext::SimportContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::SimportContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::SimportContext::IMPORT() {
  return getToken(WatParser::IMPORT, 0);
}

std::vector<WatParser::NameContext *> WatParser::SimportContext::name() {
  return getRuleContexts<WatParser::NameContext>();
}

WatParser::NameContext* WatParser::SimportContext::name(size_t i) {
  return getRuleContext<WatParser::NameContext>(i);
}

WatParser::Import_descContext* WatParser::SimportContext::import_desc() {
  return getRuleContext<WatParser::Import_descContext>(0);
}

tree::TerminalNode* WatParser::SimportContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}


size_t WatParser::SimportContext::getRuleIndex() const {
  return WatParser::RuleSimport;
}

void WatParser::SimportContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimport(this);
}

void WatParser::SimportContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimport(this);
}


std::any WatParser::SimportContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitSimport(this);
  else
    return visitor->visitChildren(this);
}

WatParser::SimportContext* WatParser::simport() {
  SimportContext *_localctx = _tracker.createInstance<SimportContext>(_ctx, getState());
  enterRule(_localctx, 96, WatParser::RuleSimport);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(741);
    match(WatParser::LPAR);
    setState(742);
    match(WatParser::IMPORT);
    setState(743);
    name();
    setState(744);
    name();
    setState(745);
    import_desc();
    setState(746);
    match(WatParser::RPAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inline_importContext ------------------------------------------------------------------

WatParser::Inline_importContext::Inline_importContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Inline_importContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::Inline_importContext::IMPORT() {
  return getToken(WatParser::IMPORT, 0);
}

std::vector<WatParser::NameContext *> WatParser::Inline_importContext::name() {
  return getRuleContexts<WatParser::NameContext>();
}

WatParser::NameContext* WatParser::Inline_importContext::name(size_t i) {
  return getRuleContext<WatParser::NameContext>(i);
}

tree::TerminalNode* WatParser::Inline_importContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}


size_t WatParser::Inline_importContext::getRuleIndex() const {
  return WatParser::RuleInline_import;
}

void WatParser::Inline_importContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInline_import(this);
}

void WatParser::Inline_importContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInline_import(this);
}


std::any WatParser::Inline_importContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitInline_import(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Inline_importContext* WatParser::inline_import() {
  Inline_importContext *_localctx = _tracker.createInstance<Inline_importContext>(_ctx, getState());
  enterRule(_localctx, 98, WatParser::RuleInline_import);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(748);
    match(WatParser::LPAR);
    setState(749);
    match(WatParser::IMPORT);
    setState(750);
    name();
    setState(751);
    name();
    setState(752);
    match(WatParser::RPAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Export_descContext ------------------------------------------------------------------

WatParser::Export_descContext::Export_descContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Export_descContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::Export_descContext::FUNC() {
  return getToken(WatParser::FUNC, 0);
}

WatParser::Var_Context* WatParser::Export_descContext::var_() {
  return getRuleContext<WatParser::Var_Context>(0);
}

tree::TerminalNode* WatParser::Export_descContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}

tree::TerminalNode* WatParser::Export_descContext::TABLE() {
  return getToken(WatParser::TABLE, 0);
}

tree::TerminalNode* WatParser::Export_descContext::MEMORY() {
  return getToken(WatParser::MEMORY, 0);
}

tree::TerminalNode* WatParser::Export_descContext::GLOBAL() {
  return getToken(WatParser::GLOBAL, 0);
}


size_t WatParser::Export_descContext::getRuleIndex() const {
  return WatParser::RuleExport_desc;
}

void WatParser::Export_descContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExport_desc(this);
}

void WatParser::Export_descContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExport_desc(this);
}


std::any WatParser::Export_descContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitExport_desc(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Export_descContext* WatParser::export_desc() {
  Export_descContext *_localctx = _tracker.createInstance<Export_descContext>(_ctx, getState());
  enterRule(_localctx, 100, WatParser::RuleExport_desc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(774);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(754);
      match(WatParser::LPAR);
      setState(755);
      match(WatParser::FUNC);
      setState(756);
      var_();
      setState(757);
      match(WatParser::RPAR);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(759);
      match(WatParser::LPAR);
      setState(760);
      match(WatParser::TABLE);
      setState(761);
      var_();
      setState(762);
      match(WatParser::RPAR);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(764);
      match(WatParser::LPAR);
      setState(765);
      match(WatParser::MEMORY);
      setState(766);
      var_();
      setState(767);
      match(WatParser::RPAR);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(769);
      match(WatParser::LPAR);
      setState(770);
      match(WatParser::GLOBAL);
      setState(771);
      var_();
      setState(772);
      match(WatParser::RPAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Export_Context ------------------------------------------------------------------

WatParser::Export_Context::Export_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Export_Context::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::Export_Context::EXPORT() {
  return getToken(WatParser::EXPORT, 0);
}

WatParser::NameContext* WatParser::Export_Context::name() {
  return getRuleContext<WatParser::NameContext>(0);
}

WatParser::Export_descContext* WatParser::Export_Context::export_desc() {
  return getRuleContext<WatParser::Export_descContext>(0);
}

tree::TerminalNode* WatParser::Export_Context::RPAR() {
  return getToken(WatParser::RPAR, 0);
}


size_t WatParser::Export_Context::getRuleIndex() const {
  return WatParser::RuleExport_;
}

void WatParser::Export_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExport_(this);
}

void WatParser::Export_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExport_(this);
}


std::any WatParser::Export_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitExport_(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Export_Context* WatParser::export_() {
  Export_Context *_localctx = _tracker.createInstance<Export_Context>(_ctx, getState());
  enterRule(_localctx, 102, WatParser::RuleExport_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(776);
    match(WatParser::LPAR);
    setState(777);
    match(WatParser::EXPORT);
    setState(778);
    name();
    setState(779);
    export_desc();
    setState(780);
    match(WatParser::RPAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inline_exportContext ------------------------------------------------------------------

WatParser::Inline_exportContext::Inline_exportContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Inline_exportContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::Inline_exportContext::EXPORT() {
  return getToken(WatParser::EXPORT, 0);
}

WatParser::NameContext* WatParser::Inline_exportContext::name() {
  return getRuleContext<WatParser::NameContext>(0);
}

tree::TerminalNode* WatParser::Inline_exportContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}


size_t WatParser::Inline_exportContext::getRuleIndex() const {
  return WatParser::RuleInline_export;
}

void WatParser::Inline_exportContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInline_export(this);
}

void WatParser::Inline_exportContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInline_export(this);
}


std::any WatParser::Inline_exportContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitInline_export(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Inline_exportContext* WatParser::inline_export() {
  Inline_exportContext *_localctx = _tracker.createInstance<Inline_exportContext>(_ctx, getState());
  enterRule(_localctx, 104, WatParser::RuleInline_export);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(782);
    match(WatParser::LPAR);
    setState(783);
    match(WatParser::EXPORT);
    setState(784);
    name();
    setState(785);
    match(WatParser::RPAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_Context ------------------------------------------------------------------

WatParser::Type_Context::Type_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Def_typeContext* WatParser::Type_Context::def_type() {
  return getRuleContext<WatParser::Def_typeContext>(0);
}


size_t WatParser::Type_Context::getRuleIndex() const {
  return WatParser::RuleType_;
}

void WatParser::Type_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_(this);
}

void WatParser::Type_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_(this);
}


std::any WatParser::Type_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitType_(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Type_Context* WatParser::type_() {
  Type_Context *_localctx = _tracker.createInstance<Type_Context>(_ctx, getState());
  enterRule(_localctx, 106, WatParser::RuleType_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(787);
    def_type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_defContext ------------------------------------------------------------------

WatParser::Type_defContext::Type_defContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Type_defContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::Type_defContext::TYPE() {
  return getToken(WatParser::TYPE, 0);
}

WatParser::Type_Context* WatParser::Type_defContext::type_() {
  return getRuleContext<WatParser::Type_Context>(0);
}

tree::TerminalNode* WatParser::Type_defContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}

WatParser::Bind_varContext* WatParser::Type_defContext::bind_var() {
  return getRuleContext<WatParser::Bind_varContext>(0);
}


size_t WatParser::Type_defContext::getRuleIndex() const {
  return WatParser::RuleType_def;
}

void WatParser::Type_defContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_def(this);
}

void WatParser::Type_defContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_def(this);
}


std::any WatParser::Type_defContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitType_def(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Type_defContext* WatParser::type_def() {
  Type_defContext *_localctx = _tracker.createInstance<Type_defContext>(_ctx, getState());
  enterRule(_localctx, 108, WatParser::RuleType_def);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(789);
    match(WatParser::LPAR);
    setState(790);
    match(WatParser::TYPE);
    setState(792);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == WatParser::VAR) {
      setState(791);
      bind_var();
    }
    setState(794);
    type_();
    setState(795);
    match(WatParser::RPAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Start_Context ------------------------------------------------------------------

WatParser::Start_Context::Start_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Start_Context::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::Start_Context::START_() {
  return getToken(WatParser::START_, 0);
}

WatParser::Var_Context* WatParser::Start_Context::var_() {
  return getRuleContext<WatParser::Var_Context>(0);
}

tree::TerminalNode* WatParser::Start_Context::RPAR() {
  return getToken(WatParser::RPAR, 0);
}


size_t WatParser::Start_Context::getRuleIndex() const {
  return WatParser::RuleStart_;
}

void WatParser::Start_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStart_(this);
}

void WatParser::Start_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStart_(this);
}


std::any WatParser::Start_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitStart_(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Start_Context* WatParser::start_() {
  Start_Context *_localctx = _tracker.createInstance<Start_Context>(_ctx, getState());
  enterRule(_localctx, 110, WatParser::RuleStart_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(797);
    match(WatParser::LPAR);
    setState(798);
    match(WatParser::START_);
    setState(799);
    var_();
    setState(800);
    match(WatParser::RPAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_fieldContext ------------------------------------------------------------------

WatParser::Module_fieldContext::Module_fieldContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Type_defContext* WatParser::Module_fieldContext::type_def() {
  return getRuleContext<WatParser::Type_defContext>(0);
}

WatParser::SglobalContext* WatParser::Module_fieldContext::sglobal() {
  return getRuleContext<WatParser::SglobalContext>(0);
}

WatParser::TableContext* WatParser::Module_fieldContext::table() {
  return getRuleContext<WatParser::TableContext>(0);
}

WatParser::MemoryContext* WatParser::Module_fieldContext::memory() {
  return getRuleContext<WatParser::MemoryContext>(0);
}

WatParser::Func_Context* WatParser::Module_fieldContext::func_() {
  return getRuleContext<WatParser::Func_Context>(0);
}

WatParser::ElemContext* WatParser::Module_fieldContext::elem() {
  return getRuleContext<WatParser::ElemContext>(0);
}

WatParser::DataContext* WatParser::Module_fieldContext::data() {
  return getRuleContext<WatParser::DataContext>(0);
}

WatParser::Start_Context* WatParser::Module_fieldContext::start_() {
  return getRuleContext<WatParser::Start_Context>(0);
}

WatParser::SimportContext* WatParser::Module_fieldContext::simport() {
  return getRuleContext<WatParser::SimportContext>(0);
}

WatParser::Export_Context* WatParser::Module_fieldContext::export_() {
  return getRuleContext<WatParser::Export_Context>(0);
}


size_t WatParser::Module_fieldContext::getRuleIndex() const {
  return WatParser::RuleModule_field;
}

void WatParser::Module_fieldContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_field(this);
}

void WatParser::Module_fieldContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_field(this);
}


std::any WatParser::Module_fieldContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitModule_field(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Module_fieldContext* WatParser::module_field() {
  Module_fieldContext *_localctx = _tracker.createInstance<Module_fieldContext>(_ctx, getState());
  enterRule(_localctx, 112, WatParser::RuleModule_field);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(812);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(802);
      type_def();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(803);
      sglobal();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(804);
      table();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(805);
      memory();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(806);
      func_();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(807);
      elem();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(808);
      data();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(809);
      start_();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(810);
      simport();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(811);
      export_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_Context ------------------------------------------------------------------

WatParser::Module_Context::Module_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Module_Context::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::Module_Context::MODULE() {
  return getToken(WatParser::MODULE, 0);
}

tree::TerminalNode* WatParser::Module_Context::RPAR() {
  return getToken(WatParser::RPAR, 0);
}

tree::TerminalNode* WatParser::Module_Context::VAR() {
  return getToken(WatParser::VAR, 0);
}

std::vector<WatParser::Module_fieldContext *> WatParser::Module_Context::module_field() {
  return getRuleContexts<WatParser::Module_fieldContext>();
}

WatParser::Module_fieldContext* WatParser::Module_Context::module_field(size_t i) {
  return getRuleContext<WatParser::Module_fieldContext>(i);
}


size_t WatParser::Module_Context::getRuleIndex() const {
  return WatParser::RuleModule_;
}

void WatParser::Module_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_(this);
}

void WatParser::Module_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_(this);
}


std::any WatParser::Module_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitModule_(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Module_Context* WatParser::module_() {
  Module_Context *_localctx = _tracker.createInstance<Module_Context>(_ctx, getState());
  enterRule(_localctx, 114, WatParser::RuleModule_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(814);
    match(WatParser::LPAR);
    setState(815);
    match(WatParser::MODULE);
    setState(817);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == WatParser::VAR) {
      setState(816);
      match(WatParser::VAR);
    }
    setState(822);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == WatParser::LPAR) {
      setState(819);
      module_field();
      setState(824);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(825);
    match(WatParser::RPAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Script_moduleContext ------------------------------------------------------------------

WatParser::Script_moduleContext::Script_moduleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Module_Context* WatParser::Script_moduleContext::module_() {
  return getRuleContext<WatParser::Module_Context>(0);
}

tree::TerminalNode* WatParser::Script_moduleContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::Script_moduleContext::MODULE() {
  return getToken(WatParser::MODULE, 0);
}

tree::TerminalNode* WatParser::Script_moduleContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}

tree::TerminalNode* WatParser::Script_moduleContext::BIN() {
  return getToken(WatParser::BIN, 0);
}

tree::TerminalNode* WatParser::Script_moduleContext::QUOTE() {
  return getToken(WatParser::QUOTE, 0);
}

tree::TerminalNode* WatParser::Script_moduleContext::VAR() {
  return getToken(WatParser::VAR, 0);
}

std::vector<tree::TerminalNode *> WatParser::Script_moduleContext::STRING_() {
  return getTokens(WatParser::STRING_);
}

tree::TerminalNode* WatParser::Script_moduleContext::STRING_(size_t i) {
  return getToken(WatParser::STRING_, i);
}


size_t WatParser::Script_moduleContext::getRuleIndex() const {
  return WatParser::RuleScript_module;
}

void WatParser::Script_moduleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScript_module(this);
}

void WatParser::Script_moduleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScript_module(this);
}


std::any WatParser::Script_moduleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitScript_module(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Script_moduleContext* WatParser::script_module() {
  Script_moduleContext *_localctx = _tracker.createInstance<Script_moduleContext>(_ctx, getState());
  enterRule(_localctx, 116, WatParser::RuleScript_module);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(841);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(827);
      module_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(828);
      match(WatParser::LPAR);
      setState(829);
      match(WatParser::MODULE);
      setState(831);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WatParser::VAR) {
        setState(830);
        match(WatParser::VAR);
      }
      setState(833);
      _la = _input->LA(1);
      if (!(_la == WatParser::BIN

      || _la == WatParser::QUOTE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(837);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WatParser::STRING_) {
        setState(834);
        match(WatParser::STRING_);
        setState(839);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(840);
      match(WatParser::RPAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Action_Context ------------------------------------------------------------------

WatParser::Action_Context::Action_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::Action_Context::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::Action_Context::INVOKE() {
  return getToken(WatParser::INVOKE, 0);
}

WatParser::NameContext* WatParser::Action_Context::name() {
  return getRuleContext<WatParser::NameContext>(0);
}

WatParser::Const_listContext* WatParser::Action_Context::const_list() {
  return getRuleContext<WatParser::Const_listContext>(0);
}

tree::TerminalNode* WatParser::Action_Context::RPAR() {
  return getToken(WatParser::RPAR, 0);
}

tree::TerminalNode* WatParser::Action_Context::VAR() {
  return getToken(WatParser::VAR, 0);
}

tree::TerminalNode* WatParser::Action_Context::GET() {
  return getToken(WatParser::GET, 0);
}


size_t WatParser::Action_Context::getRuleIndex() const {
  return WatParser::RuleAction_;
}

void WatParser::Action_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAction_(this);
}

void WatParser::Action_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAction_(this);
}


std::any WatParser::Action_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitAction_(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Action_Context* WatParser::action_() {
  Action_Context *_localctx = _tracker.createInstance<Action_Context>(_ctx, getState());
  enterRule(_localctx, 118, WatParser::RuleAction_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(860);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(843);
      match(WatParser::LPAR);
      setState(844);
      match(WatParser::INVOKE);
      setState(846);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WatParser::VAR) {
        setState(845);
        match(WatParser::VAR);
      }
      setState(848);
      name();
      setState(849);
      const_list();
      setState(850);
      match(WatParser::RPAR);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(852);
      match(WatParser::LPAR);
      setState(853);
      match(WatParser::GET);
      setState(855);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WatParser::VAR) {
        setState(854);
        match(WatParser::VAR);
      }
      setState(857);
      name();
      setState(858);
      match(WatParser::RPAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssertionContext ------------------------------------------------------------------

WatParser::AssertionContext::AssertionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::AssertionContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::AssertionContext::ASSERT_MALFORMED() {
  return getToken(WatParser::ASSERT_MALFORMED, 0);
}

WatParser::Script_moduleContext* WatParser::AssertionContext::script_module() {
  return getRuleContext<WatParser::Script_moduleContext>(0);
}

tree::TerminalNode* WatParser::AssertionContext::STRING_() {
  return getToken(WatParser::STRING_, 0);
}

tree::TerminalNode* WatParser::AssertionContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}

tree::TerminalNode* WatParser::AssertionContext::ASSERT_INVALID() {
  return getToken(WatParser::ASSERT_INVALID, 0);
}

tree::TerminalNode* WatParser::AssertionContext::ASSERT_UNLINKABLE() {
  return getToken(WatParser::ASSERT_UNLINKABLE, 0);
}

tree::TerminalNode* WatParser::AssertionContext::ASSERT_TRAP() {
  return getToken(WatParser::ASSERT_TRAP, 0);
}

tree::TerminalNode* WatParser::AssertionContext::ASSERT_RETURN() {
  return getToken(WatParser::ASSERT_RETURN, 0);
}

WatParser::Action_Context* WatParser::AssertionContext::action_() {
  return getRuleContext<WatParser::Action_Context>(0);
}

WatParser::Const_listContext* WatParser::AssertionContext::const_list() {
  return getRuleContext<WatParser::Const_listContext>(0);
}

tree::TerminalNode* WatParser::AssertionContext::ASSERT_RETURN_CANONICAL_NAN() {
  return getToken(WatParser::ASSERT_RETURN_CANONICAL_NAN, 0);
}

tree::TerminalNode* WatParser::AssertionContext::ASSERT_RETURN_ARITHMETIC_NAN() {
  return getToken(WatParser::ASSERT_RETURN_ARITHMETIC_NAN, 0);
}

tree::TerminalNode* WatParser::AssertionContext::ASSERT_EXHAUSTION() {
  return getToken(WatParser::ASSERT_EXHAUSTION, 0);
}


size_t WatParser::AssertionContext::getRuleIndex() const {
  return WatParser::RuleAssertion;
}

void WatParser::AssertionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssertion(this);
}

void WatParser::AssertionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssertion(this);
}


std::any WatParser::AssertionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitAssertion(this);
  else
    return visitor->visitChildren(this);
}

WatParser::AssertionContext* WatParser::assertion() {
  AssertionContext *_localctx = _tracker.createInstance<AssertionContext>(_ctx, getState());
  enterRule(_localctx, 120, WatParser::RuleAssertion);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(914);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(862);
      match(WatParser::LPAR);
      setState(863);
      match(WatParser::ASSERT_MALFORMED);
      setState(864);
      script_module();
      setState(865);
      match(WatParser::STRING_);
      setState(866);
      match(WatParser::RPAR);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(868);
      match(WatParser::LPAR);
      setState(869);
      match(WatParser::ASSERT_INVALID);
      setState(870);
      script_module();
      setState(871);
      match(WatParser::STRING_);
      setState(872);
      match(WatParser::RPAR);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(874);
      match(WatParser::LPAR);
      setState(875);
      match(WatParser::ASSERT_UNLINKABLE);
      setState(876);
      script_module();
      setState(877);
      match(WatParser::STRING_);
      setState(878);
      match(WatParser::RPAR);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(880);
      match(WatParser::LPAR);
      setState(881);
      match(WatParser::ASSERT_TRAP);
      setState(882);
      script_module();
      setState(883);
      match(WatParser::STRING_);
      setState(884);
      match(WatParser::RPAR);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(886);
      match(WatParser::LPAR);
      setState(887);
      match(WatParser::ASSERT_RETURN);
      setState(888);
      action_();
      setState(889);
      const_list();
      setState(890);
      match(WatParser::RPAR);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(892);
      match(WatParser::LPAR);
      setState(893);
      match(WatParser::ASSERT_RETURN_CANONICAL_NAN);
      setState(894);
      action_();
      setState(895);
      match(WatParser::RPAR);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(897);
      match(WatParser::LPAR);
      setState(898);
      match(WatParser::ASSERT_RETURN_ARITHMETIC_NAN);
      setState(899);
      action_();
      setState(900);
      match(WatParser::RPAR);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(902);
      match(WatParser::LPAR);
      setState(903);
      match(WatParser::ASSERT_TRAP);
      setState(904);
      action_();
      setState(905);
      match(WatParser::STRING_);
      setState(906);
      match(WatParser::RPAR);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(908);
      match(WatParser::LPAR);
      setState(909);
      match(WatParser::ASSERT_EXHAUSTION);
      setState(910);
      action_();
      setState(911);
      match(WatParser::STRING_);
      setState(912);
      match(WatParser::RPAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CmdContext ------------------------------------------------------------------

WatParser::CmdContext::CmdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Action_Context* WatParser::CmdContext::action_() {
  return getRuleContext<WatParser::Action_Context>(0);
}

WatParser::AssertionContext* WatParser::CmdContext::assertion() {
  return getRuleContext<WatParser::AssertionContext>(0);
}

WatParser::Script_moduleContext* WatParser::CmdContext::script_module() {
  return getRuleContext<WatParser::Script_moduleContext>(0);
}

tree::TerminalNode* WatParser::CmdContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::CmdContext::REGISTER() {
  return getToken(WatParser::REGISTER, 0);
}

WatParser::NameContext* WatParser::CmdContext::name() {
  return getRuleContext<WatParser::NameContext>(0);
}

tree::TerminalNode* WatParser::CmdContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}

tree::TerminalNode* WatParser::CmdContext::VAR() {
  return getToken(WatParser::VAR, 0);
}

WatParser::MetaContext* WatParser::CmdContext::meta() {
  return getRuleContext<WatParser::MetaContext>(0);
}


size_t WatParser::CmdContext::getRuleIndex() const {
  return WatParser::RuleCmd;
}

void WatParser::CmdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCmd(this);
}

void WatParser::CmdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCmd(this);
}


std::any WatParser::CmdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitCmd(this);
  else
    return visitor->visitChildren(this);
}

WatParser::CmdContext* WatParser::cmd() {
  CmdContext *_localctx = _tracker.createInstance<CmdContext>(_ctx, getState());
  enterRule(_localctx, 122, WatParser::RuleCmd);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(928);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 96, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(916);
      action_();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(917);
      assertion();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(918);
      script_module();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(919);
      match(WatParser::LPAR);
      setState(920);
      match(WatParser::REGISTER);
      setState(921);
      name();
      setState(923);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WatParser::VAR) {
        setState(922);
        match(WatParser::VAR);
      }
      setState(925);
      match(WatParser::RPAR);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(927);
      meta();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MetaContext ------------------------------------------------------------------

WatParser::MetaContext::MetaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::MetaContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::MetaContext::SCRIPT() {
  return getToken(WatParser::SCRIPT, 0);
}

tree::TerminalNode* WatParser::MetaContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}

tree::TerminalNode* WatParser::MetaContext::VAR() {
  return getToken(WatParser::VAR, 0);
}

std::vector<WatParser::CmdContext *> WatParser::MetaContext::cmd() {
  return getRuleContexts<WatParser::CmdContext>();
}

WatParser::CmdContext* WatParser::MetaContext::cmd(size_t i) {
  return getRuleContext<WatParser::CmdContext>(i);
}

tree::TerminalNode* WatParser::MetaContext::INPUT() {
  return getToken(WatParser::INPUT, 0);
}

tree::TerminalNode* WatParser::MetaContext::STRING_() {
  return getToken(WatParser::STRING_, 0);
}

tree::TerminalNode* WatParser::MetaContext::OUTPUT() {
  return getToken(WatParser::OUTPUT, 0);
}


size_t WatParser::MetaContext::getRuleIndex() const {
  return WatParser::RuleMeta;
}

void WatParser::MetaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeta(this);
}

void WatParser::MetaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeta(this);
}


std::any WatParser::MetaContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitMeta(this);
  else
    return visitor->visitChildren(this);
}

WatParser::MetaContext* WatParser::meta() {
  MetaContext *_localctx = _tracker.createInstance<MetaContext>(_ctx, getState());
  enterRule(_localctx, 124, WatParser::RuleMeta);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(962);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(930);
      match(WatParser::LPAR);
      setState(931);
      match(WatParser::SCRIPT);
      setState(933);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WatParser::VAR) {
        setState(932);
        match(WatParser::VAR);
      }
      setState(938);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WatParser::LPAR) {
        setState(935);
        cmd();
        setState(940);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(941);
      match(WatParser::RPAR);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(942);
      match(WatParser::LPAR);
      setState(943);
      match(WatParser::INPUT);
      setState(945);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WatParser::VAR) {
        setState(944);
        match(WatParser::VAR);
      }
      setState(947);
      match(WatParser::STRING_);
      setState(948);
      match(WatParser::RPAR);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(949);
      match(WatParser::LPAR);
      setState(950);
      match(WatParser::OUTPUT);
      setState(952);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WatParser::VAR) {
        setState(951);
        match(WatParser::VAR);
      }
      setState(954);
      match(WatParser::STRING_);
      setState(955);
      match(WatParser::RPAR);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(956);
      match(WatParser::LPAR);
      setState(957);
      match(WatParser::OUTPUT);
      setState(959);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WatParser::VAR) {
        setState(958);
        match(WatParser::VAR);
      }
      setState(961);
      match(WatParser::RPAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WconstContext ------------------------------------------------------------------

WatParser::WconstContext::WconstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::WconstContext::LPAR() {
  return getToken(WatParser::LPAR, 0);
}

tree::TerminalNode* WatParser::WconstContext::CONST() {
  return getToken(WatParser::CONST, 0);
}

WatParser::LiteralContext* WatParser::WconstContext::literal() {
  return getRuleContext<WatParser::LiteralContext>(0);
}

tree::TerminalNode* WatParser::WconstContext::RPAR() {
  return getToken(WatParser::RPAR, 0);
}


size_t WatParser::WconstContext::getRuleIndex() const {
  return WatParser::RuleWconst;
}

void WatParser::WconstContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWconst(this);
}

void WatParser::WconstContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWconst(this);
}


std::any WatParser::WconstContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitWconst(this);
  else
    return visitor->visitChildren(this);
}

WatParser::WconstContext* WatParser::wconst() {
  WconstContext *_localctx = _tracker.createInstance<WconstContext>(_ctx, getState());
  enterRule(_localctx, 126, WatParser::RuleWconst);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(964);
    match(WatParser::LPAR);
    setState(965);
    match(WatParser::CONST);
    setState(966);
    literal();
    setState(967);
    match(WatParser::RPAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_listContext ------------------------------------------------------------------

WatParser::Const_listContext::Const_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<WatParser::WconstContext *> WatParser::Const_listContext::wconst() {
  return getRuleContexts<WatParser::WconstContext>();
}

WatParser::WconstContext* WatParser::Const_listContext::wconst(size_t i) {
  return getRuleContext<WatParser::WconstContext>(i);
}


size_t WatParser::Const_listContext::getRuleIndex() const {
  return WatParser::RuleConst_list;
}

void WatParser::Const_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_list(this);
}

void WatParser::Const_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_list(this);
}


std::any WatParser::Const_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitConst_list(this);
  else
    return visitor->visitChildren(this);
}

WatParser::Const_listContext* WatParser::const_list() {
  Const_listContext *_localctx = _tracker.createInstance<Const_listContext>(_ctx, getState());
  enterRule(_localctx, 128, WatParser::RuleConst_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(972);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == WatParser::LPAR) {
      setState(969);
      wconst();
      setState(974);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScriptContext ------------------------------------------------------------------

WatParser::ScriptContext::ScriptContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WatParser::ScriptContext::EOF() {
  return getToken(WatParser::EOF, 0);
}

std::vector<WatParser::CmdContext *> WatParser::ScriptContext::cmd() {
  return getRuleContexts<WatParser::CmdContext>();
}

WatParser::CmdContext* WatParser::ScriptContext::cmd(size_t i) {
  return getRuleContext<WatParser::CmdContext>(i);
}

std::vector<WatParser::Module_fieldContext *> WatParser::ScriptContext::module_field() {
  return getRuleContexts<WatParser::Module_fieldContext>();
}

WatParser::Module_fieldContext* WatParser::ScriptContext::module_field(size_t i) {
  return getRuleContext<WatParser::Module_fieldContext>(i);
}


size_t WatParser::ScriptContext::getRuleIndex() const {
  return WatParser::RuleScript;
}

void WatParser::ScriptContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScript(this);
}

void WatParser::ScriptContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScript(this);
}


std::any WatParser::ScriptContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitScript(this);
  else
    return visitor->visitChildren(this);
}

WatParser::ScriptContext* WatParser::script() {
  ScriptContext *_localctx = _tracker.createInstance<ScriptContext>(_ctx, getState());
  enterRule(_localctx, 130, WatParser::RuleScript);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(989);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(978);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WatParser::LPAR) {
        setState(975);
        cmd();
        setState(980);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(981);
      match(WatParser::EOF);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(983); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(982);
        module_field();
        setState(985); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == WatParser::LPAR);
      setState(987);
      match(WatParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleContext ------------------------------------------------------------------

WatParser::ModuleContext::ModuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WatParser::Module_Context* WatParser::ModuleContext::module_() {
  return getRuleContext<WatParser::Module_Context>(0);
}

tree::TerminalNode* WatParser::ModuleContext::EOF() {
  return getToken(WatParser::EOF, 0);
}

std::vector<WatParser::Module_fieldContext *> WatParser::ModuleContext::module_field() {
  return getRuleContexts<WatParser::Module_fieldContext>();
}

WatParser::Module_fieldContext* WatParser::ModuleContext::module_field(size_t i) {
  return getRuleContext<WatParser::Module_fieldContext>(i);
}


size_t WatParser::ModuleContext::getRuleIndex() const {
  return WatParser::RuleModule;
}

void WatParser::ModuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule(this);
}

void WatParser::ModuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WatParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule(this);
}


std::any WatParser::ModuleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<WatParserVisitor*>(visitor))
    return parserVisitor->visitModule(this);
  else
    return visitor->visitChildren(this);
}

WatParser::ModuleContext* WatParser::module() {
  ModuleContext *_localctx = _tracker.createInstance<ModuleContext>(_ctx, getState());
  enterRule(_localctx, 132, WatParser::RuleModule);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1001);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(991);
      module_();
      setState(992);
      match(WatParser::EOF);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(997);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WatParser::LPAR) {
        setState(994);
        module_field();
        setState(999);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1000);
      match(WatParser::EOF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

void WatParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  watparserParserInitialize();
#else
  ::antlr4::internal::call_once(watparserParserOnceFlag, watparserParserInitialize);
#endif
}
